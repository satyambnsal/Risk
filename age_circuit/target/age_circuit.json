{"noir_version":"1.0.0-beta.4+0000000000000000000000000000000000000000","hash":"3952567357376305604","abi":{"parameters":[{"name":"age","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7Z3NattAGEXfRWsvfO+n0czkVUopTuIWg3GCkxRKyLtXKnV/qDE+Q1dhNgHZc2WHo8XH0R3rdbjf3r58+bQ7fH54Gm4+vA77h7vN8+7hMB+9Dvrx0tPj5rAcPT1vjs/DTWg1bA/3w824flsNn3f77XCT1m8fV4PZ8mDLR7Y8nVuuMf1cr5T/DKz+WVrq6dTV8WupvZx7Ondu1/IzEFL7ufP5fzOfzh1T67nng9vjbr/fffn0F+X18ifKuc+99EWj0sS4xgnhhHEicGLEiYQTE05knMDMR8w8YeYJM0+YecLME2aeMPOEmSfMPGHmCTOfMPMJM58w8wkznzDzCTOfMPMJM58w8wkzz5h5xswzZp4x84yZZ8w8Y+YZM8+YecbMC2ZeMPOCmRfMvGDmBTMvmHnBzAtmXjDziplXzLxi5hUzr5h5xcwrZl4x84qZV8xc6zWPiEfMI8EjI48kHpl4JPNI4RFOX5y+OH1x+uL0xemL0xenL05fnL44fXP65vTN6ZvTN6dvTt+cvjl9c/rm9IPTD04/OP3g9IPTD04/OP3g9LmuE/d14sJO3NiJKztxZycu7cStnbi2E/d24uJO3NyJqztxdycu78Ttnbi+E/d34gJP3OCJKzxxhycu8cQtnrjGE/d44iJP501eHk/3YXJZ/xOZeCTzSGGR+UDLwoaZlF+a/MrEFyafR/k4yqdRPozyWZSPonwS5YMon0P5GMqnUD6E8hmUj6B8AuUDKJ8/+fjZbxaDBGbebxaDRL9ZfH2i3yy+PvGfbhZfGuX4iEknzLcfnazXPmX1KatPWX3K6lNWn7L6lNWnrHc3ZV1M9Ere9Yleybs+0St51yd6Je/6RK/kXZ/olTwS6ZU8GumVPBrplTwa6ZU8GumVPBrplTwa6ZU8GumVPBrplTwa6ZU8Gnn3lbzLEU6fuzxxmSdu88R1nrjPExd64kZPXOmJOz3lhsojp8+1nrjXExd74mZPXO2Juz1xuSdu98T1nkpD45XT54ZPXPGJOz5xySdu+cQ1n7jnExd94qZPtaHw3NDF4WUc7vrMXZ+56zN3feauz9z1mbs+c9dn7vqshioWp89dn7nrM3d95q7P3PWZuz5z1+eGHl5DEa+licfpN3TxGsp4DW28hjpeQx+voZDHXZ+56zN3fY6GIianz12fueszd33mrs/c9Zm7PnPXZ+76zF2fx4YeLqfPXZ+56zN3feauz9z1mbs+c9dn7vrMXZ+56zN3feauz9z1mbs+c9dn7vrMXZ+56zN3feauz1NDC5/T567P3PWZuz5z12fu+sxdn7nrM3d95q7PuWETBqfPXZ+56zN3feauz9z1mbs+c9dn7vrMXZ9Lwx4cTp+7PnPXZ+76zF2fueszd33mrs/c9Zm7PteGLVgNe7D4Jizu+oK7vuCuL7jrC+76gru+4K4vuOsL7vpCDVvwOH3u+oK7vuCuL7jrC+76gru+4K4vuOsL7vrCDTswOX3u+oK7vuCuL7jrC+76wvAnd5ZIxZHzru/C5u756OvmuNvc7rdPc2J58+Vwd3qsw3z4/O3x9M7pwQ+Px4e77f3Lcbs8AuKPpz/MH+20ivRx6SPPB8rr1XzL/fevBy0vTmWV4/em8uWlCK8i8vxl5i/0HQ==","file_map":{"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n","path":"std/lib.nr"},"50":{"source":"fn main(age: u32) {\n    assert(age >= 18);\n    let message = \"Noir Gud\";\n    let arr = message.as_bytes().map(|charCode| charCode as Field);\n    println(arr);\n    // let field_arr = arr;\n\n\n    let hash = std::hash::pedersen_hash(arr);\n\n    let commitment = std::hash::pedersen_commitment(arr);\n    println(hash);\n    println(commitment);\n}\n\n#[test]\nfn test_main() {\n    main(20);\n}\n","path":"/Users/satyam/projects/aztec-projects/risk-next/age_circuit/src/main.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","print_unconstrained","directive_integer_quotient"]}