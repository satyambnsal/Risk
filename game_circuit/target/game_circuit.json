{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":8681208900618481431,"abi":{"parameters":[{"name":"num_players","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"random_seed","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"common::GameState","fields":[{"name":"game_ended","type":{"kind":"boolean"}},{"name":"turn_count","type":{"kind":"field"}},{"name":"current_player","type":{"kind":"field"}},{"name":"territories","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"mpc_state","type":{"kind":"struct","path":"common::MPCState","fields":[{"name":"user_encrypt_secret_hashes","type":{"kind":"array","length":6,"type":{"kind":"field"}}},{"name":"user_mask_secret_hashes","type":{"kind":"array","length":6,"type":{"kind":"field"}}},{"name":"round_id","type":{"kind":"field"}}]}},{"name":"winner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"15803065596631416538":{"error_kind":"string","string":"Invalid number of players"}}},"bytecode":"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","debug_symbols":"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","file_map":{"25":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"62":{"source":"// game_initialization.nr\nuse dep::std;\nuse std::hash::poseidon2::Poseidon2::hash as poseidon2;\n\nuse crate::common::{AdjacencyMap, GameState, MPCState, PlayerState, Territory};\nuse crate::common::constants::{\n    INITIAL_TROOPS_PER_PLAYER, MAX_PLAYERS, MAX_TERRITORIES, MIN_REINFORCEMENTS,\n};\n\npub fn initialize_game_state(num_players: u32) -> GameState {\n    // Validate number of players\n    assert(num_players >= 2 & num_players <= MAX_PLAYERS, \"Invalid number of players\");\n\n    let mut game_state = GameState::default();\n\n    // Initialize territories\n    for i in 0..MAX_TERRITORIES {\n        let mut territory = Territory::default();\n        territory.id = i as Field;\n        game_state.territories[i] = territory;\n    }\n\n    game_state.game_ended = false;\n    game_state.turn_count = 0;\n    game_state.current_player = 1;\n    game_state.winner = 0;\n\n    game_state\n}\n\npub fn initialize_player_state(\n    player_id: Field,\n    encrypt_secret: Field,\n    mask_secret: Field,\n) -> PlayerState {\n    // Validate player ID\n    assert(player_id as u32 > 0 & player_id as u32 <= MAX_PLAYERS, \"Invalid player ID\");\n\n    // Validate secrets are non-zero\n    assert(encrypt_secret != 0, \"Encryption secret cannot be zero\");\n    assert(mask_secret != 0, \"Mask secret cannot be zero\");\n\n    let mut player_state = PlayerState::default();\n    player_state.player_id = player_id;\n    player_state.encrypt_secret = encrypt_secret;\n    player_state.mask_secret = mask_secret;\n    player_state.unallocated_troops = INITIAL_TROOPS_PER_PLAYER;\n    player_state.reinforcements = 0;\n    player_state.has_conquered_territory = false;\n\n    // Initialize territory visibility to false\n    for i in 0..MAX_TERRITORIES {\n        player_state.visible_territories[i] = false;\n    }\n\n    // Initialize territory view\n    for i in 0..MAX_TERRITORIES {\n        let mut territory = Territory::default();\n        territory.id = i as Field;\n        player_state.territories_view[i] = territory;\n    }\n\n    player_state\n}\n\npub fn create_risk_adjacency_map() -> AdjacencyMap {\n    let mut map = AdjacencyMap::default();\n\n    // This is a simplified version of Risk map adjacencies\n    // North America (9 territories)\n    map = map.add_adjacency(0, 1); // Alaska - Northwest Territory\n    map = map.add_adjacency(0, 3); // Alaska - Kamchatka (across the Bering Strait)\n    map = map.add_adjacency(1, 2); // Northwest Territory - Greenland\n    map = map.add_adjacency(1, 4); // Northwest Territory - Alberta\n    map = map.add_adjacency(2, 6); // Greenland - Quebec\n    // map = map.add_adjacency(2, 14); // Greenland - Iceland\n    map = map.add_adjacency(3, 4); // Alberta - Ontario\n    map = map.add_adjacency(4, 5); // Ontario - Quebec\n    map = map.add_adjacency(4, 7); // Ontario - Eastern United States\n    map = map.add_adjacency(5, 7); // Quebec - Eastern United States\n    map = map.add_adjacency(6, 7); // Western United States - Eastern United States\n    map = map.add_adjacency(6, 8); // Western United States - Central America\n    map = map.add_adjacency(8, 9); // Central America - Venezuela\n\n    // South America (4 territories)\n    map = map.add_adjacency(9, 10); // Venezuela - Peru\n    map = map.add_adjacency(9, 11); // Venezuela - Brazil\n    map = map.add_adjacency(10, 11); // Peru - Brazil\n    map = map.add_adjacency(10, 12); // Peru - Argentina\n    map = map.add_adjacency(11, 12); // Brazil - Argentina\n    map = map.add_adjacency(11, 15); // Brazil - North Africa\n\n    // // Europe (7 territories)\n    map = map.add_adjacency(13, 14); // Great Britain - Iceland\n    map = map.add_adjacency(13, 15); // Great Britain - Western Europe\n    map = map.add_adjacency(13, 16); // Great Britain - Northern Europe\n    map = map.add_adjacency(13, 17); // Great Britain - Scandinavia\n    map = map.add_adjacency(14, 17); // Iceland - Scandinavia\n    map = map.add_adjacency(15, 16); // Western Europe - Northern Europe\n    map = map.add_adjacency(15, 18); // Western Europe - Southern Europe\n    map = map.add_adjacency(15, 21); // Western Europe - North Africa\n    map = map.add_adjacency(16, 17); // Northern Europe - Scandinavia\n    map = map.add_adjacency(16, 18); // Northern Europe - Southern Europe\n    map = map.add_adjacency(16, 19); // Northern Europe - Ukraine\n    map = map.add_adjacency(17, 19); // Scandinavia - Ukraine\n    map = map.add_adjacency(18, 19); // Southern Europe - Ukraine\n    map = map.add_adjacency(18, 21); // Southern Europe - North Africa\n    map = map.add_adjacency(18, 22); // Southern Europe - Egypt\n    // map = map.add_adjacency(18, 24); // Southern Europe - Middle East\n\n    // // Africa (6 territories)\n    map = map.add_adjacency(20, 21); // Congo - North Africa\n    map = map.add_adjacency(20, 22); // Congo - Egypt\n    map = map.add_adjacency(20, 23); // Congo - East Africa\n    // map = map.add_adjacency(20, 25); // Congo - South Africa\n    // map = map.add_adjacency(21, 22); // North Africa - Egypt\n    // map = map.add_adjacency(22, 23); // Egypt - East Africa\n    // map = map.add_adjacency(22, 24); // Egypt - Middle East\n    // map = map.add_adjacency(23, 24); // East Africa - Middle East\n    // map = map.add_adjacency(23, 25); // East Africa - South Africa\n    // map = map.add_adjacency(23, 26); // East Africa - Madagascar\n    // map = map.add_adjacency(25, 26); // South Africa - Madagascar\n\n    // // Asia (12 territories)\n    // map = map.add_adjacency(19, 24); // Ukraine - Middle East\n    // map = map.add_adjacency(19, 27); // Ukraine - Afghanistan\n    // map = map.add_adjacency(19, 28); // Ukraine - Ural\n    // map = map.add_adjacency(24, 27); // Middle East - Afghanistan\n    // map = map.add_adjacency(24, 31); // Middle East - India\n    // map = map.add_adjacency(27, 28); // Afghanistan - Ural\n    // map = map.add_adjacency(27, 29); // Afghanistan - China\n    // map = map.add_adjacency(27, 31); // Afghanistan - India\n    // map = map.add_adjacency(28, 29); // Ural - China\n    // map = map.add_adjacency(28, 30); // Ural - Siberia\n    // map = map.add_adjacency(29, 30); // China - Siberia\n    // map = map.add_adjacency(29, 31); // China - India\n    // map = map.add_adjacency(29, 32); // China - Siam\n    // map = map.add_adjacency(29, 33); // China - Mongolia\n    // map = map.add_adjacency(29, 34); // China - Japan\n    // map = map.add_adjacency(30, 33); // Siberia - Mongolia\n    // map = map.add_adjacency(30, 35); // Siberia - Irkutsk\n    // map = map.add_adjacency(30, 36); // Siberia - Yakutsk\n    // map = map.add_adjacency(31, 32); // India - Siam\n    // map = map.add_adjacency(32, 37); // Siam - Indonesia\n    // map = map.add_adjacency(33, 34); // Mongolia - Japan\n    // map = map.add_adjacency(33, 35); // Mongolia - Irkutsk\n    // map = map.add_adjacency(33, 41); // Mongolia - Kamchatka\n    // map = map.add_adjacency(35, 36); // Irkutsk - Yakutsk\n    // map = map.add_adjacency(35, 41); // Irkutsk - Kamchatka\n    // map = map.add_adjacency(36, 41); // Yakutsk - Kamchatka\n    // map = map.add_adjacency(37, 38); // Indonesia - New Guinea\n    // map = map.add_adjacency(37, 39); // Indonesia - Western Australia\n    // map = map.add_adjacency(38, 39); // New Guinea - Western Australia\n    // map = map.add_adjacency(38, 40); // New Guinea - Eastern Australia\n    // map = map.add_adjacency(39, 40); // Western Australia - Eastern Australia\n    // map = map.add_adjacency(41, 0); // Kamchatka - Alaska (complete the loop)\n\n    map\n}\n\npub fn assign_initial_territories(\n    game_state: GameState,\n    num_players: u32,\n    random_seed: Field,\n) -> GameState {\n    // Validate number of players\n    assert(num_players >= 2 & num_players <= MAX_PLAYERS, \"Invalid number of players\");\n\n    let mut updated_state = game_state;\n\n    // Create deterministic \"random\" assignments based on the seed\n    for i in 0..MAX_TERRITORIES {\n        // Use poseidon hash to create pseudorandom values based on seed and territory ID\n        let hash_input = [random_seed, i as Field];\n        let rand_value = poseidon2(hash_input, 2);\n\n        // Assign to player 1 through num_players\n        let player = (rand_value as u32 % num_players) + 1;\n\n        // Update the game state\n        updated_state.territories[i].owner_id = player as Field;\n        updated_state.territories[i].troop_count = 1; // Start with 1 troop per territory\n    }\n\n    updated_state\n}\n\npub fn commit_to_user_secrets(\n    game_state: GameState,\n    encrypt_secret: Field,\n    mask_secret: Field,\n    player_id: Field,\n) -> GameState {\n    assert(player_id as u32 > 0 & player_id as u32 <= MAX_PLAYERS, \"Invalid player ID\");\n    assert(encrypt_secret != 0, \"Encryption secret cannot be zero\");\n    assert(mask_secret != 0, \"Mask secret cannot be zero\");\n\n    let mut updated = game_state;\n\n    // Hash the secrets to create commitments\n    let encrypt_hash = poseidon2([encrypt_secret, player_id], 2);\n    let mask_hash = poseidon2([mask_secret, player_id], 2);\n\n    // Store the commitments\n    let idx = (player_id - 1) as u32;\n    updated.mpc_state.user_encrypt_secret_hashes[idx] = encrypt_hash;\n    updated.mpc_state.user_mask_secret_hashes[idx] = mask_hash;\n\n    updated\n}\n\npub fn register_all_players(\n    game_state: GameState,\n    player_secrets: [(Field, Field); MAX_PLAYERS],\n) -> GameState {\n    let mut updated = game_state;\n\n    for i in 0..MAX_PLAYERS {\n        let player_id = (i + 1) as Field;\n        let (encrypt_secret, mask_secret) = player_secrets[i];\n\n        // Only process valid players with non-zero secrets\n        if (encrypt_secret as u32 != 0) & (mask_secret as u32 != 0) {\n            updated = commit_to_user_secrets(updated, encrypt_secret, mask_secret, player_id);\n        }\n    }\n\n    updated\n}\n\n// Count territories owned by each player\npub fn count_player_territories(game_state: GameState) -> [Field; MAX_PLAYERS + 1] {\n    let mut counts = [0; MAX_PLAYERS + 1];\n\n    for i in 0..MAX_TERRITORIES {\n        let owner = game_state.territories[i].owner_id;\n        if owner as u32 > 0 & owner as u32 <= MAX_PLAYERS {\n            let owner_idx = owner as u32;\n            counts[owner_idx] += 1;\n        }\n    }\n\n    counts\n}\n\n// Calculate reinforcements for a player\npub fn calculate_reinforcements(game_state: GameState, player_id: Field) -> Field {\n    let territory_counts = count_player_territories(game_state);\n    let player_idx = player_id as u32;\n    let player_territory_count = territory_counts[player_idx];\n\n    // Basic rule: Number of territories divided by 3, with a minimum of 3\n    let reinforcements = player_territory_count / 3;\n\n    if reinforcements as u32 < MIN_REINFORCEMENTS {\n        MIN_REINFORCEMENTS as Field\n    } else {\n        reinforcements\n    }\n\n    // Note: In a real game, you would add continent bonuses here\n}\n\n// Get player's initial reinforcements at the start of their turn\npub fn get_turn_reinforcements(game_state: GameState, player_state: PlayerState) -> PlayerState {\n    assert(game_state.current_player == player_state.player_id, \"Not this player's turn\");\n\n    let reinforcements = calculate_reinforcements(game_state, player_state.player_id);\n\n    // Update player state with new reinforcements\n    let mut updated_player = player_state;\n    updated_player.reinforcements = reinforcements as u32;\n    updated_player.unallocated_troops += reinforcements as u32;\n\n    updated_player\n}\n","path":"/Users/satyam/web3/noir/Risk/game_circuit/src/game_initialization.nr"},"64":{"source":"mod common;\n\n// mod visibility;\nmod game_initialization;\nmod game_mechanics;\nmod mpc;\n\nuse crate::common::{\n    AdjacencyMap, AttackMove, FortifyMove, GameMove, GameState, PlayerState, TroopPlacementMove,\n};\nuse crate::common::constants;\n\nfn main(num_players: u32, random_seed: Field) -> pub GameState {\n    let game_state = game_initialization::initialize_game_state(num_players);\n    let adjacency_map = game_initialization::create_risk_adjacency_map();\n\n    // Assign territories to players\n    let updated_game =\n        game_initialization::assign_initial_territories(game_state, num_players, random_seed);\n\n    updated_game\n}\n\nfn register_player(\n    game_state: GameState,\n    player_id: Field,\n    encrypt_secret: Field,\n    mask_secret: Field,\n) -> pub (GameState, PlayerState) {\n    // Initialize player state\n    let player_state =\n        game_initialization::initialize_player_state(player_id, encrypt_secret, mask_secret);\n\n    // Commit player secrets to the game state\n    let updated_game = game_initialization::commit_to_user_secrets(\n        game_state,\n        encrypt_secret,\n        mask_secret,\n        player_id,\n    );\n\n    // Update player's visibility and view\n    let updated_player = mpc::update_territory_visibility(player_state, updated_game);\n    let final_player = mpc::update_player_view(updated_game, updated_player);\n\n    (updated_game, final_player)\n}\n\nfn place_troops(\n    game_state: GameState,\n    player_state: PlayerState,\n    territory_id: Field,\n    troop_count: u32,\n) -> pub (GameState, PlayerState, bool) {\n    let move_data = TroopPlacementMove { territory_id: territory_id, troop_count: troop_count };\n\n    let game_move = GameMove::PlaceTroops(move_data);\n    let adjacency_map = game_initialization::create_risk_adjacency_map();\n\n    let (updated_game, updated_player, success) =\n        game_mechanics::execute_move(game_state, player_state, adjacency_map, game_move);\n\n    (updated_game, updated_player, success)\n}\n\nfn attack(\n    game_state: GameState,\n    player_state: PlayerState,\n    from_territory_id: Field,\n    to_territory_id: Field,\n    attack_troop_count: u32,\n    dice_roll_seed: Field,\n) -> pub (GameState, PlayerState, bool, u32, u32, bool) {\n    let move_data = AttackMove {\n        from_territory_id: from_territory_id,\n        to_territory_id: to_territory_id,\n        attack_troop_count: attack_troop_count,\n        dice_roll_seed: dice_roll_seed,\n    };\n\n    let adjacency_map = game_initialization::create_risk_adjacency_map();\n\n    let (updated_game, updated_player, result) =\n        game_mechanics::execute_attack(game_state, player_state, adjacency_map, move_data);\n\n    (\n        updated_game, updated_player, result.success, result.attacker_losses,\n        result.defender_losses, result.territory_captured,\n    )\n}\n","path":"/Users/satyam/web3/noir/Risk/game_circuit/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}