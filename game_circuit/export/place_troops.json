{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":4213894671666919002,"abi":{"parameters":[{"name":"game_state","type":{"kind":"struct","path":"common::GameState","fields":[{"name":"game_ended","type":{"kind":"boolean"}},{"name":"turn_count","type":{"kind":"field"}},{"name":"current_player","type":{"kind":"field"}},{"name":"territories","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"mpc_state","type":{"kind":"struct","path":"common::MPCState","fields":[{"name":"user_encrypt_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"user_mask_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"round_id","type":{"kind":"field"}}]}},{"name":"winner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"player_state","type":{"kind":"struct","path":"common::PlayerState","fields":[{"name":"player_id","type":{"kind":"field"}},{"name":"encrypt_secret","type":{"kind":"field"}},{"name":"mask_secret","type":{"kind":"field"}},{"name":"visible_territories","type":{"kind":"array","length":24,"type":{"kind":"boolean"}}},{"name":"territories_view","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"unallocated_troops","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"reinforcements","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"has_conquered_territory","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"move_data","type":{"kind":"struct","path":"common::TroopPlacementMove","fields":[{"name":"territory_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"struct","path":"common::GameState","fields":[{"name":"game_ended","type":{"kind":"boolean"}},{"name":"turn_count","type":{"kind":"field"}},{"name":"current_player","type":{"kind":"field"}},{"name":"territories","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"mpc_state","type":{"kind":"struct","path":"common::MPCState","fields":[{"name":"user_encrypt_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"user_mask_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"round_id","type":{"kind":"field"}}]}},{"name":"winner","type":{"kind":"field"}}]},{"kind":"struct","path":"common::PlayerState","fields":[{"name":"player_id","type":{"kind":"field"}},{"name":"encrypt_secret","type":{"kind":"field"}},{"name":"mask_secret","type":{"kind":"field"}},{"name":"visible_territories","type":{"kind":"array","length":24,"type":{"kind":"boolean"}}},{"name":"territories_view","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"unallocated_troops","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"reinforcements","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"has_conquered_territory","type":{"kind":"boolean"}}]},{"kind":"boolean"}]},"visibility":"private"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}}},"bytecode":"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","debug_symbols":"nZvdShtRGEXfZa69mLPP33d8lVIkapRAiBJjoYjv3iimiJla9rrLzLCGCWsFwiZ5mW7X18/3V5vd3cPTdPnjZdo+3KwOm4fd8ehl6vF+7ulxtXs7fDqs9ofpsuW4mNa72+OrGK8X091mu347+/rzYurDJWK2iWQTWiJ66R9Eb+0rkW2i2ES1iWYT3SbCJoZLjNkmFp13lb9E/0rIJvL3RMz6ShSbqDbRbGLReWSdiHL2zsMmhkukefaRRetR5xMy2hkiH8k+Unxk0fzQCRktzpDmI4vuU8onJqVez6Ag0ABQmgmU/gfp7DOQkgiUyeMVAlUCNQKRIhIpIpEiRIpQIpAIRIoQKUKkCJEiRIoQKUKkiEyKyKSITIrIpIhMisikiEyKyKSITIrIpIhCiiikiEKKKKSIQooopIhCiiikiEKKKKSISoqopIhKiqikiEqKqKSISoqopIhKiqikiEaKaKSIRopopIhGimikiEaKaKSIRopopIhOiuikiE6K6KSIToropIhOiuikiE6K6KSIIEUEKSJIEUGKCFJEkCKCFBGkiCBFBClikCIGKWKQIgYpYpAiBilikCIGKWKQIgYoQvNMoEQgESgTqBCoEqgRqBMoCESKIJulEikikSLIZimyWYpsliKbpchmKbJZimyWIpulyGYpslmKbJYim6XIZimyWYpsliKbpchmKbJZimyWIpulyGYpslmKbJYim6XIZimyWYpsliKbpchmKbJZimyWIpulyGYpslmKbJYim6XIZimyWYpsliKbpchmKbJZimyWIpulyGYpslmKbJYim6XIZql/bJbHb5wn6PgwZ1Am0GIR3/1mQa36SPOR7iPhI8NGlnfK75HkI/KR7CO+/e7b77797tvvvv3u2w/ffvj2w7cfvv3w7YdvP3z74dsP33749odvf/j2h29/+PaHb3/49odvf/j2h29/2PbzPPtI8hH5SPaR4iPVR5qPdB8JH/HtJ99+8u0n337y7SfffvLtJ99+8u0n337y7cu3L9++fPvy7cu3L9++fPvy7cu3L99+9u1n33727WfffvbtZ9P+8eB6v9luN/dXn/+fdDz9a7XfrK6364/Du+fdzaerh9+Ppysn/nH/cLO+fd6v3+70fu14+z8=","file_map":{"63":{"source":"// game_mechanics.nr\nuse dep::std;\nuse std::hash::poseidon2::Poseidon2::hash as poseidon2;\n\nuse crate::common::{\n    AdjacencyMap, AttackMove, AttackResult, FortifyMove, GameMove, GameState, PlayerState,\n    Territory, TroopPlacementMove,\n};\nuse crate::common::constants::{MAX_PLAYERS, MAX_TERRITORIES};\n\n// Place troops on a territory\n#[export]\npub fn place_troops(\n    game_state: GameState,\n    player_state: PlayerState,\n    move_data: TroopPlacementMove,\n) -> (GameState, PlayerState, bool) {\n    let territory_id = move_data.territory_id;\n    let troop_count = move_data.troop_count;\n\n    // Validation checks\n    let player_turn = game_state.current_player == player_state.player_id;\n    let owns_territory =\n        game_state.territories[territory_id as u32].owner_id == player_state.player_id;\n    let has_enough_troops = troop_count > 0 & troop_count <= player_state.unallocated_troops;\n\n    let valid_move = player_turn & owns_territory & has_enough_troops;\n\n    if valid_move {\n        // Update game and player state\n        let mut updated_game = game_state;\n        let mut updated_player = player_state;\n\n        updated_game.territories[territory_id as u32].troop_count += troop_count;\n        updated_player.unallocated_troops -= troop_count;\n\n        (updated_game, updated_player, true)\n    } else {\n        (game_state, player_state, false)\n    }\n}\n\n// Generate a dice roll using player secrets for randomness\nfn roll_dice(\n    attacker_secret: Field,\n    defender_id: Field,\n    from_territory: Field,\n    to_territory: Field,\n    num_dice: u32,\n    nonce: Field,\n) -> [u32; 3] {\n    // Return up to 3 dice values\n    let mut dice_values = [0; 3];\n\n    for i in 0..3 {\n        if i < num_dice {\n            // Create a unique seed for each die\n            let hash_input =\n                [attacker_secret, defender_id, from_territory, to_territory, i as Field, nonce];\n\n            let seed = poseidon2(hash_input, 6);\n\n            // Convert to a number between 1-6\n            dice_values[i] = ((seed as u32 % 6) + 1) as u32;\n        }\n    }\n\n    dice_values\n}\n\n// Sort an array of dice values in descending order\nunconstrained fn sort_dice(dice: [u32; 3], count: u32) -> [u32; 3] {\n    let mut sorted = dice;\n\n    // Simple bubble sort\n    for i in 0..count {\n        for j in 0..(count - i - 1) {\n            if sorted[j] < sorted[j + 1] {\n                let temp = sorted[j];\n                sorted[j] = sorted[j + 1];\n                sorted[j + 1] = temp;\n            }\n        }\n    }\n\n    sorted\n}\n\n#[export]\npub fn execute_attack(\n    game_state: GameState,\n    player_state: PlayerState,\n    adjacency_map: AdjacencyMap,\n    move_data: AttackMove,\n) -> (GameState, PlayerState, AttackResult) {\n    let from_territory_id = move_data.from_territory_id as u32;\n    let to_territory_id = move_data.to_territory_id as u32;\n    let attack_troop_count = move_data.attack_troop_count;\n\n    // Default result\n    let mut result = AttackResult::default();\n\n    // Validation checks\n    let player_turn = game_state.current_player == player_state.player_id;\n    let owns_from = game_state.territories[from_territory_id].owner_id == player_state.player_id;\n    let doesnt_own_to = game_state.territories[to_territory_id].owner_id != player_state.player_id;\n    let territories_adjacent =\n        adjacency_map.are_adjacent(from_territory_id as Field, to_territory_id as Field);\n    let from_troops = game_state.territories[from_territory_id].troop_count;\n    let has_enough_troops = attack_troop_count > 0 & attack_troop_count < from_troops;\n\n    let valid_attack =\n        player_turn & owns_from & doesnt_own_to & territories_adjacent & has_enough_troops;\n\n    assert(valid_attack == true, \"attack should be valid\");\n\n    // The attack is valid, proceed with the battle\n    result.success = true;\n\n    // Determine number of dice\n    let attacker_dice = if attack_troop_count >= 3 {\n        3\n    } else {\n        attack_troop_count\n    };\n\n    let defender_troops = game_state.territories[to_territory_id].troop_count;\n    let defender_dice = if defender_troops >= 2 { 2 } else { 1 };\n\n    // Roll and sort dice\n    let defender_id = game_state.territories[to_territory_id].owner_id;\n    let nonce = move_data.dice_roll_seed;\n\n    let attacker_rolls = roll_dice(\n        player_state.encrypt_secret,\n        defender_id,\n        from_territory_id as Field,\n        to_territory_id as Field,\n        attacker_dice,\n        nonce,\n    );\n\n    // Simulate defender rolls (in real game, defender would use their own secret)\n    let defender_secret = poseidon2([player_state.encrypt_secret, defender_id], 2);\n\n    let defender_rolls = roll_dice(\n        defender_secret,\n        player_state.player_id,\n        to_territory_id as Field,\n        from_territory_id as Field,\n        defender_dice,\n        nonce,\n    );\n    println(f\"attacker roles: {attacker_rolls}\");\n    println(f\"defender roles: {defender_rolls}\");\n    let mut sorted_attacker = [0, 0, 0];\n    let mut sorted_defender = [0, 0, 0];\n\n    unsafe {\n        sorted_attacker = sort_dice(attacker_rolls, attacker_dice);\n        sorted_defender = sort_dice(defender_rolls, defender_dice);\n    }\n    // Sort dice in descending order\n\n    // Compare dice and compute casualties\n    let mut attacker_losses = 0;\n    let mut defender_losses = 0;\n    let compare_count = if defender_dice < attacker_dice {\n        defender_dice\n    } else {\n        attacker_dice\n    };\n\n    unsafe {\n        let result = calculate_losses(compare_count, sorted_attacker, sorted_defender);\n        attacker_losses = result.0;\n        defender_losses = result.1;\n    }\n    // Update result with battle outcome\n    result.attacker_losses = attacker_losses;\n    result.defender_losses = defender_losses;\n\n    // Update game state based on the outcome\n    let mut updated_game = game_state;\n    let mut updated_player = player_state;\n\n    // Check if the territory was conquered\n    let territory_conquered = defender_losses >= defender_troops;\n    result.territory_captured = territory_conquered;\n\n    if territory_conquered {\n        // Attacker conquers the territory\n        let remaining_attack_troops = attack_troop_count - attacker_losses;\n        updated_game.territories[to_territory_id].owner_id = player_state.player_id;\n        updated_game.territories[to_territory_id].troop_count = remaining_attack_troops;\n        updated_game.territories[from_territory_id].troop_count -=\n            (remaining_attack_troops + attacker_losses);\n\n        // Mark that player has conquered a territory this turn (for cards)\n        updated_player.has_conquered_territory = true;\n    } else {\n        // Defender keeps the territory with reduced troops\n        updated_game.territories[from_territory_id].troop_count -= attacker_losses;\n        updated_game.territories[to_territory_id].troop_count -= defender_losses;\n    }\n\n    // Check for win condition\n    updated_game = check_win_condition(updated_game);\n\n    (updated_game, updated_player, result)\n}\n\n#[export]\npub fn execute_fortify(\n    game_state: GameState,\n    player_state: PlayerState,\n    adjacency_map: AdjacencyMap,\n    move_data: FortifyMove,\n) -> (GameState, PlayerState, bool) {\n    let from_territory_id = move_data.from_territory_id as u32;\n    let to_territory_id = move_data.to_territory_id as u32;\n    let troop_count = move_data.troop_count;\n\n    // Validation checks\n    let player_turn = game_state.current_player == player_state.player_id;\n    let owns_from = game_state.territories[from_territory_id].owner_id == player_state.player_id;\n    let owns_to = game_state.territories[to_territory_id].owner_id == player_state.player_id;\n    let territories_adjacent =\n        adjacency_map.are_adjacent(from_territory_id as Field, to_territory_id as Field);\n    let from_troops = game_state.territories[from_territory_id].troop_count;\n    let has_enough_troops = troop_count > 0 & troop_count < from_troops;\n\n    let valid_fortify =\n        player_turn & owns_from & owns_to & territories_adjacent & has_enough_troops;\n\n    if valid_fortify {\n        // Update game state\n        let mut updated_game = game_state;\n\n        updated_game.territories[from_territory_id].troop_count -= troop_count;\n        updated_game.territories[to_territory_id].troop_count += troop_count;\n\n        (updated_game, player_state, true)\n    } else {\n        (game_state, player_state, false)\n    }\n}\n\n#[export]\npub fn check_win_condition(game_state: GameState) -> GameState {\n    let mut updated_game = game_state;\n    let territory_counts = count_player_territories(game_state);\n\n    // Check if any player owns all territories\n    for player_id in 1..=MAX_PLAYERS {\n        if territory_counts[player_id] as u32 == MAX_TERRITORIES {\n            updated_game.game_ended = true;\n            updated_game.winner = player_id as Field;\n        }\n    }\n\n    updated_game\n}\n\n// Count territories owned by each player\npub fn count_player_territories(game_state: GameState) -> [Field; MAX_PLAYERS + 1] {\n    let mut counts = [0; MAX_PLAYERS + 1];\n\n    for i in 0..MAX_TERRITORIES {\n        let owner = game_state.territories[i].owner_id;\n        if owner as u32 > 0 & owner as u32 <= MAX_PLAYERS {\n            let owner_idx = owner as u32;\n            counts[owner_idx] += 1;\n        }\n    }\n\n    counts\n}\n\n#[export]\npub fn end_turn(game_state: GameState) -> GameState {\n    // Ensure the game has not ended\n    assert(!game_state.game_ended, \"Game has already ended\");\n\n    let mut updated_game = game_state;\n\n    // Find the next active player\n    let current_player = game_state.current_player;\n    let mut next_player = current_player + 1;\n\n    // Wrap around to player 1 if we reach beyond max players\n    if next_player as u32 > MAX_PLAYERS {\n        next_player = 1;\n    }\n\n    // Update game state\n    updated_game.current_player = next_player;\n    updated_game.turn_count += 1;\n\n    updated_game\n}\n\npub fn execute_move(\n    game_state: GameState,\n    player_state: PlayerState,\n    adjacency_map: AdjacencyMap,\n    game_move: GameMove,\n) -> (GameState, PlayerState, bool) {\n    match game_move {\n        GameMove::PlaceTroops(move_data) => { place_troops(game_state, player_state, move_data) },\n        GameMove::Attack(move_data) => {\n            let (updated_game, updated_player, result) =\n                execute_attack(game_state, player_state, adjacency_map, move_data);\n            (updated_game, updated_player, result.success)\n        },\n        GameMove::Fortify(move_data) => {\n            execute_fortify(game_state, player_state, adjacency_map, move_data)\n        },\n        GameMove::EndTurn => {\n            if game_state.current_player == player_state.player_id {\n                let updated_game = end_turn(game_state);\n                (updated_game, player_state, true)\n            } else {\n                (game_state, player_state, false)\n            }\n        },\n        _ => (game_state, player_state, false),\n    }\n}\n\nunconstrained fn calculate_losses(\n    compare_count: u32,\n    sorted_attacker: [u32; 3],\n    sorted_defender: [u32; 3],\n) -> (u32, u32) {\n    let mut defender_losses = 0;\n    let mut attacker_losses = 0;\n    for i in 0..compare_count {\n        if sorted_attacker[i] > sorted_defender[i] {\n            defender_losses += 1;\n        } else {\n            attacker_losses += 1;\n        }\n    }\n    (attacker_losses, defender_losses)\n}\n","path":"/Users/satyam/web3/noir/Risk/game_circuit/src/game_mechanics.nr"}},"names":["place_troops"],"brillig_names":["directive_invert","directive_integer_quotient"]}