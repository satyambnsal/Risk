{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":10636756629549735801,"abi":{"parameters":[{"name":"num_players","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"common::GameState","fields":[{"name":"game_ended","type":{"kind":"boolean"}},{"name":"turn_count","type":{"kind":"field"}},{"name":"current_player","type":{"kind":"field"}},{"name":"territories","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"mpc_state","type":{"kind":"struct","path":"common::MPCState","fields":[{"name":"user_encrypt_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"user_mask_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"round_id","type":{"kind":"field"}}]}},{"name":"winner","type":{"kind":"field"}}]},"visibility":"private"},"error_types":{"15803065596631416538":{"error_kind":"string","string":"Invalid number of players"}}},"bytecode":"H4sIAAAAAAAA/9Wb6W7TQBSF7SQQmlAolH1N2XfGW2Kzln2nbZY//EuoI/GHR+AdeCeeAl4GHzKWrMRUqnxvpTPSaNxOOvpyztQez73jOrMyyuoXe+1mtW5blE5WG/a65iyW/HPrtjXViicx1nRW0hLcqmN7+UVRi75tB/MCDqyAxVJXFCww3TBMe37qBd7Y+MkkjkwYTbqxF3tRHG37cRCkcRj3kknSM4kXBqk3jRJ/asfqVx8rsGOZgaCRu5mAVbkFJ4lfgqsyAYe2HeWC5BMQv+jMAdQVBas6AYeCXCMlI6UnXN+RvRlocQ73iNNUK54rN5bR5KyRcNYd2XuFFmeDRM99JJz7STibJPPzAImeSyScLQHfU7vC1ORsk+h5kIRzWc73VJPzEImeh0k4V+R839bkPEKi51ESzlU5379qch4j0fM4CecJOd8nmpwnSfQ8RcJ5Ws73sSbnGRI9z5JwnpPzPdHkPE+i5wUSzotyvseanB0SPddIOC/J+d7T5LxMoucVEs6rcr53NTmvkeh5nYTzhpzvkSbnTRI9b5Fw3pbzPdTkvEOi510SzntyvgeanPdJ9DQknJ6c774mp0+iZ0DCGcr5rpofEpHo2SXh7Mn5rsoZk+iZkHA+EPM9VY2/PyTR8xEJ52M531Xj709I9HxKwrku57tq/P0ZiZ7PSThfyPmuGn9/SaLnKxLO13K+q8bf35Do+ZaE852c72NNzvcken4g4fxIwvmJhPMzCecGCecmCeeWMKfrLJatAnvNmZ3pw/kXnC3BuQ2cicB5A+TyI08eOejI70buNPKSkfO7klXkqiIPFDmWyF9EbiDy7pDThnwx5GIhzwk5RMjPQe4L8kqQs9HJ6lpWEcdHjBzxZ8R2ETdFTBLxPsTSEKdCDAjxFcQuEBfAnju+HDb6sA+LPU7sH2JvDvte2FPCfg32QrDPgHd4vB/j3RPvdfk7E9b6WEdjjYr1H9ZWWLdgTYDnLZ5leE7gHoz7G+4d+L/EnN+0OtYKujZt+/vHt5/ff238KXT907Osz53rX7Jtq9BfPENlqhU/H7+tM75pOoulVbhuz/Xl+jVK/s79z8+1uXanz7o7jLtc0pePuWrbIm/+Pf4C4rv6sPo+AAA=","debug_symbols":"ldFbCsMgEAXQvcx3fhqbB26llOAzCKLio1Ake68JFUJbKP5553IGZDJwQdO6KCNtAHzLoC0jUVlTUobLMQqOmD2FSHwEjNDUgTC8vAa0dSCVFoDHfrt30LcC1AquP8EwVjD3H2BoBWMrmP784QvMbaAE6pXWal3O1ynjB/GKUC3eUSbDTm18utpU77xlgicv9k1HV9a/AA==","file_map":{"62":{"source":"use std::hash::poseidon2::Poseidon2::hash as poseidon2;\n\nuse crate::common::{AdjacencyMap, GameState, MPCState, PlayerState, Territory};\nuse crate::common::constants::{\n    INITIAL_TROOPS_PER_PLAYER, MAX_PLAYERS, MAX_TERRITORIES, MIN_REINFORCEMENTS,\n};\n\n#[export]\npub fn initialize_game_state(num_players: u32) -> GameState {\n    assert(num_players >= 2 & num_players <= MAX_PLAYERS, \"Invalid number of players\");\n\n    let mut game_state = GameState::default();\n\n    for i in 0..MAX_TERRITORIES {\n        let mut territory = Territory::default();\n        territory.id = i as Field;\n        game_state.territories[i] = territory;\n    }\n\n    game_state.game_ended = false;\n    game_state.turn_count = 0;\n    game_state.current_player = 1;\n    game_state.winner = 0;\n\n    game_state\n}\n\n#[export]\npub fn initialize_player_state(\n    player_id: Field,\n    encrypt_secret: Field,\n    mask_secret: Field,\n) -> PlayerState {\n    assert(player_id as u32 > 0 & player_id as u32 <= MAX_PLAYERS, \"Invalid player ID\");\n\n    // Validate secrets are non-zero\n    assert(encrypt_secret != 0, \"Encryption secret cannot be zero\");\n    assert(mask_secret != 0, \"Mask secret cannot be zero\");\n\n    let mut player_state = PlayerState::default();\n    player_state.player_id = player_id;\n    player_state.encrypt_secret = encrypt_secret;\n    player_state.mask_secret = mask_secret;\n    player_state.unallocated_troops = INITIAL_TROOPS_PER_PLAYER;\n    player_state.reinforcements = 0;\n    player_state.has_conquered_territory = false;\n\n    // Initialize territory visibility to false\n    for i in 0..MAX_TERRITORIES {\n        player_state.visible_territories[i] = false;\n    }\n\n    // Initialize territory view\n    for i in 0..MAX_TERRITORIES {\n        let mut territory = Territory::default();\n        territory.id = i as Field;\n        player_state.territories_view[i] = territory;\n    }\n\n    player_state\n}\n\n#[export]\npub fn create_risk_adjacency_map() -> AdjacencyMap {\n    let mut map = AdjacencyMap::default();\n\n    // Simple version of risk map with just 24 territories due to Noir bitshift constraint\n    // North America (9 territories)\n    map = map.add_adjacency(0, 1); // Alaska - Northwest Territory\n    map = map.add_adjacency(0, 3); // Alaska - Kamchatka (across the Bering Strait)\n    map = map.add_adjacency(1, 2); // Northwest Territory - Greenland\n    map = map.add_adjacency(1, 4); // Northwest Territory - Alberta\n    map = map.add_adjacency(2, 6); // Greenland - Quebec\n    map = map.add_adjacency(2, 14); // Greenland - Iceland\n    map = map.add_adjacency(3, 4); // Alberta - Ontario\n    map = map.add_adjacency(4, 5); // Ontario - Quebec\n    map = map.add_adjacency(4, 7); // Ontario - Eastern United States\n    map = map.add_adjacency(5, 7); // Quebec - Eastern United States\n    map = map.add_adjacency(6, 7); // Western United States - Eastern United States\n    map = map.add_adjacency(6, 8); // Western United States - Central America\n    map = map.add_adjacency(8, 9); // Central America - Venezuela\n\n    // South America (4 territories)\n    map = map.add_adjacency(9, 10); // Venezuela - Peru\n    map = map.add_adjacency(9, 11); // Venezuela - Brazil\n    map = map.add_adjacency(10, 11); // Peru - Brazil\n    map = map.add_adjacency(10, 12); // Peru - Argentina\n    map = map.add_adjacency(11, 12); // Brazil - Argentina\n    map = map.add_adjacency(11, 15); // Brazil - North Africa\n\n    // // Europe (7 territories)\n    map = map.add_adjacency(13, 14); // Great Britain - Iceland\n    map = map.add_adjacency(13, 15); // Great Britain - Western Europe\n    map = map.add_adjacency(13, 16); // Great Britain - Northern Europe\n    map = map.add_adjacency(13, 17); // Great Britain - Scandinavia\n    map = map.add_adjacency(14, 17); // Iceland - Scandinavia\n    map = map.add_adjacency(15, 16); // Western Europe - Northern Europe\n    map = map.add_adjacency(15, 18); // Western Europe - Southern Europe\n    map = map.add_adjacency(15, 21); // Western Europe - North Africa\n    map = map.add_adjacency(16, 17); // Northern Europe - Scandinavia\n    map = map.add_adjacency(16, 18); // Northern Europe - Southern Europe\n    map = map.add_adjacency(16, 19); // Northern Europe - Ukraine\n    map = map.add_adjacency(17, 19); // Scandinavia - Ukraine\n    map = map.add_adjacency(18, 19); // Southern Europe - Ukraine\n    map = map.add_adjacency(18, 21); // Southern Europe - North Africa\n    map = map.add_adjacency(18, 22); // Southern Europe - Egypt\n    // map = map.add_adjacency(18, 24); // Southern Europe - Middle East\n\n    // // Africa (6 territories)\n    map = map.add_adjacency(20, 21); // Congo - North Africa\n    map = map.add_adjacency(20, 22); // Congo - Egypt\n    map = map.add_adjacency(20, 23); // Congo - East Africa\n\n    map\n}\n\n#[export]\npub fn assign_initial_territories(\n    game_state: GameState,\n    num_players: u32,\n    random_seed: Field,\n) -> GameState {\n    assert(num_players >= 2 & num_players <= MAX_PLAYERS, \"Invalid number of players\");\n\n    let mut updated_state = game_state;\n\n    // Create deterministic \"random\" assignments based on the seed\n    for i in 0..MAX_TERRITORIES {\n        // Use poseidon hash to create pseudorandom values based on seed and territory ID\n        let hash_input = [random_seed, i as Field];\n        let rand_value = poseidon2(hash_input, 2);\n\n        // Assign to player 1 through num_players\n        let player = (rand_value as u32 % num_players) + 1;\n\n        // Update the game state\n        updated_state.territories[i].owner_id = player as Field;\n        updated_state.territories[i].troop_count = 1; // Start with 1 troop per territory\n    }\n\n    updated_state\n}\n\n#[export]\npub fn commit_to_user_secrets(\n    game_state: GameState,\n    encrypt_secret: Field,\n    mask_secret: Field,\n    player_id: Field,\n) -> GameState {\n    assert(player_id as u32 > 0 & player_id as u32 <= MAX_PLAYERS, \"Invalid player ID\");\n    assert(encrypt_secret != 0, \"Encryption secret cannot be zero\");\n    assert(mask_secret != 0, \"Mask secret cannot be zero\");\n\n    let mut updated = game_state;\n\n    // Hash the secrets to create commitments\n    let encrypt_hash = poseidon2([encrypt_secret, player_id], 2);\n    let mask_hash = poseidon2([mask_secret, player_id], 2);\n\n    // Store the commitments\n    let idx = (player_id - 1) as u32;\n    updated.mpc_state.user_encrypt_secret_hashes[idx] = encrypt_hash;\n    updated.mpc_state.user_mask_secret_hashes[idx] = mask_hash;\n\n    updated\n}\n\n#[export]\npub fn register_all_players(\n    game_state: GameState,\n    player_secrets: [(Field, Field); MAX_PLAYERS],\n) -> GameState {\n    let mut updated = game_state;\n\n    for i in 0..MAX_PLAYERS {\n        let player_id = (i + 1) as Field;\n        let (encrypt_secret, mask_secret) = player_secrets[i];\n\n        // Only process valid players with non-zero secrets\n        if (encrypt_secret as u32 != 0) & (mask_secret as u32 != 0) {\n            updated = commit_to_user_secrets(updated, encrypt_secret, mask_secret, player_id);\n        }\n    }\n\n    updated\n}\n\n#[export]\npub fn count_player_territories(game_state: GameState) -> [Field; MAX_PLAYERS + 1] {\n    let mut counts = [0; MAX_PLAYERS + 1];\n\n    for i in 0..MAX_TERRITORIES {\n        let owner = game_state.territories[i].owner_id;\n        if owner as u32 > 0 & owner as u32 <= MAX_PLAYERS {\n            let owner_idx = owner as u32;\n            counts[owner_idx] += 1;\n        }\n    }\n\n    counts\n}\n\npub fn calculate_reinforcements(game_state: GameState, player_id: Field) -> Field {\n    let territory_counts = count_player_territories(game_state);\n    let player_idx = player_id as u32;\n    let player_territory_count = territory_counts[player_idx];\n\n    // Basic rule: Number of territories divided by 3, with a minimum of 3\n    let reinforcements = player_territory_count / 3;\n\n    if reinforcements as u32 < MIN_REINFORCEMENTS {\n        MIN_REINFORCEMENTS as Field\n    } else {\n        reinforcements\n    }\n}\n\npub fn get_turn_reinforcements(game_state: GameState, player_state: PlayerState) -> PlayerState {\n    assert(game_state.current_player == player_state.player_id, \"Not this player's turn\");\n\n    let reinforcements = calculate_reinforcements(game_state, player_state.player_id);\n\n    // Update player state with new reinforcements\n    let mut updated_player = player_state;\n    updated_player.reinforcements = reinforcements as u32;\n    updated_player.unallocated_troops += reinforcements as u32;\n\n    updated_player\n}\n","path":"/Users/satyam/web3/noir/Risk/game_circuit/src/game_initialization.nr"}},"names":["initialize_game_state"],"brillig_names":["directive_integer_quotient"]}