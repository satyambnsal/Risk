{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":9146554502866258320,"abi":{"parameters":[{"name":"game_state","type":{"kind":"struct","path":"common::GameState","fields":[{"name":"game_ended","type":{"kind":"boolean"}},{"name":"turn_count","type":{"kind":"field"}},{"name":"current_player","type":{"kind":"field"}},{"name":"territories","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"mpc_state","type":{"kind":"struct","path":"common::MPCState","fields":[{"name":"user_encrypt_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"user_mask_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"round_id","type":{"kind":"field"}}]}},{"name":"winner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"player_state","type":{"kind":"struct","path":"common::PlayerState","fields":[{"name":"player_id","type":{"kind":"field"}},{"name":"encrypt_secret","type":{"kind":"field"}},{"name":"mask_secret","type":{"kind":"field"}},{"name":"visible_territories","type":{"kind":"array","length":24,"type":{"kind":"boolean"}}},{"name":"territories_view","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"unallocated_troops","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"reinforcements","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"has_conquered_territory","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"adjacency_map","type":{"kind":"struct","path":"common::AdjacencyMap","fields":[{"name":"adjacency","type":{"kind":"array","length":24,"type":{"kind":"integer","sign":"unsigned","width":32}}}]},"visibility":"private"},{"name":"move_data","type":{"kind":"struct","path":"common::AttackMove","fields":[{"name":"from_territory_id","type":{"kind":"field"}},{"name":"to_territory_id","type":{"kind":"field"}},{"name":"attack_troop_count","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"dice_roll_seed","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"struct","path":"common::GameState","fields":[{"name":"game_ended","type":{"kind":"boolean"}},{"name":"turn_count","type":{"kind":"field"}},{"name":"current_player","type":{"kind":"field"}},{"name":"territories","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"mpc_state","type":{"kind":"struct","path":"common::MPCState","fields":[{"name":"user_encrypt_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"user_mask_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"round_id","type":{"kind":"field"}}]}},{"name":"winner","type":{"kind":"field"}}]},{"kind":"struct","path":"common::PlayerState","fields":[{"name":"player_id","type":{"kind":"field"}},{"name":"encrypt_secret","type":{"kind":"field"}},{"name":"mask_secret","type":{"kind":"field"}},{"name":"visible_territories","type":{"kind":"array","length":24,"type":{"kind":"boolean"}}},{"name":"territories_view","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"unallocated_troops","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"reinforcements","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"has_conquered_territory","type":{"kind":"boolean"}}]},{"kind":"struct","path":"common::AttackResult","fields":[{"name":"success","type":{"kind":"boolean"}},{"name":"attacker_losses","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"defender_losses","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"territory_captured","type":{"kind":"boolean"}}]}]},"visibility":"private"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5736200405146212474":{"error_kind":"string","string":"attack should be valid"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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/XDxjRQuvpHC9fzuFC6+kcLFN1K5+EYq1/O7U8nmZyWbnx+eH7zqh4tvpHLxjVQuvpHKxTeSLD+YZPnBJMsPJll+MMnyg0mWH8zXyA9m5a2foduxRPaXGP0lqr/EbC/xGvG6qxLSX0L7S1h/CX/dEnbc3R79JbK/RP/u9v7d7f27O/p3d/Tv7ujf3dG/u8P7S/T/7o7+3R2jv0T1l3iF3V263UqU1aHEa0R7rkpIa4n9hz/98OHbbz/89Y/ffv/1Vz99+P67H5+k29N/zu/EmnE77LM+/mM6n/o9v1fqs4q5qji/3+izCllW6LLClhW+rIhlRS4rltd8Lq/5XF5z2bZ1iaxLdF1i6xJfl8S6JNclY11S65L11Zf11Zf11Zf11Zf11Zf11Zf11Zf11Zf11Zf11Zf11df11df11df11df11df11df11df11df11df11df11bf11bf11bf11bf11bf11bf11bf11bf11bf11bf11ff11ff11ff11ff11ff11ff11ff11ff11ff11ff11Y/11Y/11Y/11Y/11Y/11Y/11Y/11Y/11Y/11Y/11c/11c/11c/11c/11c/11c/11c/11c/11c/11c/11R/rqz/WV3+sr/5YX/2xvvpjffXH+uqP9dUf66s/1le/1le/1le/1le/1le/1le/1le/1ld/ne/JOuCTdcIn64hP1hmfrEM+Wad8so75ZJ3zyTrok3XSJ+uoT9ZZn66zPl1nfbrO+nSd9ek669N11qfrrE/XWZ+usz5dZ326zvp0nfXpOuvTddan66xP11mfrrM+XWd9us76dJ316Trr03XWp+usT9dZn66zPl1nfbrO+nSd9ek669N11qfrrE/XWZ+usz5dZ326zvp0nfXpOuvTddan66xP11mfrrM+XWd9us76dJ316Trr03XWp+usT9dZn66zPl1nfbrO+nSd9ek669N11qfrrE/XWZ+usz5dZ326zvr0nPWV3G57Lo/nknPW93mJrEt0XWJrkv0HeXrh+abZPzDe7Ffl/me1u/af9/uc75sr1fnWuVQJpFJIZZDq9Bju48vtZvt9LPFnmnNX7GfKuGl81HPNaXf7NHK7x2qfMsZzjQOaADQJaMalRp/niM+h7oVmrmvOse6FxgBNrvtgAO+nXng/vt01/vzexHNSeaFRQGOAxgFNAJoENC/4Ou7nA8vn54MqQDPXNXMDNC/44J4P2jXP87ZTAY0BGgc0AWgS0AxAU5d+O2rm+jnkhXsIP1/ohbsI94uoj5U2P4gcEQUiSkQ0EFEhogmIzjnjfq3nd5GPg0gQkSIiQ0SOiAIRJSI6d4Trfd+6Hb7f5Jw7XokmININEQkiUkRkiMgRUSCiRESII7SA07Ii53LbEJEgIkVEhogcEQUiSkQ0EBHiCFt2xP6DPr00Xri2308796tZOUS3YiKq3CCVQKoXru3lPlg9/fn5VXoapHJI9dKRH/JRdWACAyIdAyId46X3Neuu2j+xe64KSJWQakCqglQTUdUGqV5YZf3E8/uHHz//K9fVlyqDVA6pAlIlpBqQ6l/xxkE1X1qvT84AOvTnf+X692pXTog/TodUAakSUmFHfiJH/oUM3rVMMJliMsNkwKL9vP/0P1/98OGrP337zVNo9ukv//7d17cM7f7jT//7t9vf3FK2f/vh+6+/+fPff/jmKW/7MWr71PXw9+W/NLP/oPsYomO7f57w9P8k6r2Mub/k6eUW7z1uLxe39+L1y7XPLz/O9xJyn1ieXu/xPj6+fmea+zu6v17G/uPc39L+tv4P","file_map":{"25":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"61":{"source":"pub mod constants {\n    pub global MAX_PLAYERS: u32 = 2;\n    pub global MAX_TERRITORIES: u32 = 24;\n    pub global MAX_TROOPS_PER_TERRITORY: u32 = 100;\n    pub global INITIAL_TROOPS_PER_PLAYER: u32 = 40;\n    pub global MIN_REINFORCEMENTS: u32 = 3;\n}\n\npub struct Territory {\n    pub id: Field,\n    pub owner_id: Field,\n    pub troop_count: u32,\n}\n\nimpl Territory {\n    pub fn default() -> Self {\n        Territory { id: 0, owner_id: 0, troop_count: 0 }\n    }\n\n    pub fn encode(self) -> Field {\n        let id_part = self.id;\n        let owner_part = self.owner_id * 0x100;\n        let troops_part = (self.troop_count as Field) * 0x10000;\n\n        id_part + owner_part + troops_part\n    }\n\n    pub fn decode(encoded: Field) -> Self {\n        let id = encoded as u32 % 0x100;\n        let owner_id = (encoded as u32 / 0x100) % 0x100;\n        let troop_count = ((encoded as u32 / 0x10000) % 0x10000) as u32;\n\n        Territory { id: id as Field, owner_id: owner_id as Field, troop_count: troop_count }\n    }\n}\n\npub struct AdjacencyMap {\n    pub adjacency: [u32; constants::MAX_TERRITORIES],\n}\n\nimpl AdjacencyMap {\n    pub fn default() -> Self {\n        AdjacencyMap { adjacency: [0; constants::MAX_TERRITORIES] }\n    }\n\n    pub fn are_adjacent(self, from_territory: Field, to_territory: Field) -> bool {\n        let from_idx = from_territory as u32;\n        let to_bit = 1 << (to_territory as u8);\n\n        (self.adjacency[from_idx] & to_bit) != 0\n    }\n\n    // Add an adjacency between two territories (bidirectional)\n    pub fn add_adjacency(mut self, territory1: Field, territory2: Field) -> Self {\n        assert(\n            territory1 as u32 >= 0 & territory1 as u32 < constants::MAX_TERRITORIES,\n            \"Territory1 ID out of bounds\",\n        );\n        assert(\n            territory2 as u32 >= 0 & territory2 as u32 < constants::MAX_TERRITORIES,\n            \"Territory2 ID out of bounds\",\n        );\n\n        let t1_idx = territory1 as u32;\n        let t2_idx = territory2 as u32;\n\n        let t2_bit = 1 << t2_idx as u8;\n        let t1_bit = 1 << t1_idx as u8;\n\n        self.adjacency[t1_idx] |= t2_bit;\n        self.adjacency[t2_idx] |= t1_bit;\n\n        self\n    }\n}\n\npub struct MPCState {\n    pub user_encrypt_secret_hashes: [Field; constants::MAX_PLAYERS],\n    pub user_mask_secret_hashes: [Field; constants::MAX_PLAYERS],\n    pub round_id: Field,\n}\n\nimpl MPCState {\n    pub fn default() -> Self {\n        MPCState {\n            user_encrypt_secret_hashes: [0; constants::MAX_PLAYERS],\n            user_mask_secret_hashes: [0; constants::MAX_PLAYERS],\n            round_id: 0,\n        }\n    }\n}\n\npub struct GameState {\n    pub game_ended: bool,\n    pub turn_count: Field,\n    pub current_player: Field,\n    pub territories: [Territory; constants::MAX_TERRITORIES],\n    pub mpc_state: MPCState,\n    pub winner: Field, // 0 means no winner yet\n}\n\nimpl GameState {\n    pub fn default() -> Self {\n        GameState {\n            game_ended: false,\n            turn_count: 0,\n            current_player: 1,\n            territories: [Territory::default(); constants::MAX_TERRITORIES],\n            mpc_state: MPCState::default(),\n            winner: 0,\n        }\n    }\n}\n\npub struct PlayerState {\n    pub player_id: Field,\n    pub encrypt_secret: Field,\n    pub mask_secret: Field,\n    pub visible_territories: [bool; constants::MAX_TERRITORIES],\n    pub territories_view: [Territory; constants::MAX_TERRITORIES],\n    pub unallocated_troops: u32,\n    pub reinforcements: u32,\n    pub has_conquered_territory: bool,\n}\n\nimpl PlayerState {\n    pub fn default() -> Self {\n        PlayerState {\n            player_id: 0,\n            encrypt_secret: 0,\n            mask_secret: 0,\n            visible_territories: [false; constants::MAX_TERRITORIES],\n            territories_view: [Territory::default(); constants::MAX_TERRITORIES],\n            unallocated_troops: 0,\n            reinforcements: 0,\n            has_conquered_territory: false,\n        }\n    }\n}\n\npub struct TroopPlacementMove {\n    pub territory_id: Field,\n    pub troop_count: u32,\n}\n\npub struct AttackMove {\n    pub from_territory_id: Field,\n    pub to_territory_id: Field,\n    pub attack_troop_count: u32,\n    pub dice_roll_seed: Field,\n}\n\npub struct FortifyMove {\n    pub from_territory_id: Field,\n    pub to_territory_id: Field,\n    pub troop_count: u32,\n}\n\npub enum GameMove {\n    PlaceTroops(TroopPlacementMove),\n    Attack(AttackMove),\n    Fortify(FortifyMove),\n    EndTurn,\n}\n\npub struct AttackResult {\n    pub success: bool,\n    pub attacker_losses: u32,\n    pub defender_losses: u32,\n    pub territory_captured: bool,\n}\n\nimpl AttackResult {\n    pub fn default() -> Self {\n        AttackResult {\n            success: false,\n            attacker_losses: 0,\n            defender_losses: 0,\n            territory_captured: false,\n        }\n    }\n}\n","path":"/Users/satyam/web3/noir/Risk/game_circuit/src/common.nr"},"63":{"source":"// game_mechanics.nr\nuse dep::std;\nuse std::hash::poseidon2::Poseidon2::hash as poseidon2;\n\nuse crate::common::{\n    AdjacencyMap, AttackMove, AttackResult, FortifyMove, GameMove, GameState, PlayerState,\n    Territory, TroopPlacementMove,\n};\nuse crate::common::constants::{MAX_PLAYERS, MAX_TERRITORIES};\n\n// Place troops on a territory\n#[export]\npub fn place_troops(\n    game_state: GameState,\n    player_state: PlayerState,\n    move_data: TroopPlacementMove,\n) -> (GameState, PlayerState, bool) {\n    let territory_id = move_data.territory_id;\n    let troop_count = move_data.troop_count;\n\n    // Validation checks\n    let player_turn = game_state.current_player == player_state.player_id;\n    let owns_territory =\n        game_state.territories[territory_id as u32].owner_id == player_state.player_id;\n    let has_enough_troops = troop_count > 0 & troop_count <= player_state.unallocated_troops;\n\n    let valid_move = player_turn & owns_territory & has_enough_troops;\n\n    if valid_move {\n        // Update game and player state\n        let mut updated_game = game_state;\n        let mut updated_player = player_state;\n\n        updated_game.territories[territory_id as u32].troop_count += troop_count;\n        updated_player.unallocated_troops -= troop_count;\n\n        (updated_game, updated_player, true)\n    } else {\n        (game_state, player_state, false)\n    }\n}\n\n// Generate a dice roll using player secrets for randomness\nfn roll_dice(\n    attacker_secret: Field,\n    defender_id: Field,\n    from_territory: Field,\n    to_territory: Field,\n    num_dice: u32,\n    nonce: Field,\n) -> [u32; 3] {\n    // Return up to 3 dice values\n    let mut dice_values = [0; 3];\n\n    for i in 0..3 {\n        if i < num_dice {\n            // Create a unique seed for each die\n            let hash_input =\n                [attacker_secret, defender_id, from_territory, to_territory, i as Field, nonce];\n\n            let seed = poseidon2(hash_input, 6);\n\n            // Convert to a number between 1-6\n            dice_values[i] = ((seed as u32 % 6) + 1) as u32;\n        }\n    }\n\n    dice_values\n}\n\n// Sort an array of dice values in descending order\nunconstrained fn sort_dice(dice: [u32; 3], count: u32) -> [u32; 3] {\n    let mut sorted = dice;\n\n    // Simple bubble sort\n    for i in 0..count {\n        for j in 0..(count - i - 1) {\n            if sorted[j] < sorted[j + 1] {\n                let temp = sorted[j];\n                sorted[j] = sorted[j + 1];\n                sorted[j + 1] = temp;\n            }\n        }\n    }\n\n    sorted\n}\n\n#[export]\npub fn execute_attack(\n    game_state: GameState,\n    player_state: PlayerState,\n    adjacency_map: AdjacencyMap,\n    move_data: AttackMove,\n) -> (GameState, PlayerState, AttackResult) {\n    let from_territory_id = move_data.from_territory_id as u32;\n    let to_territory_id = move_data.to_territory_id as u32;\n    let attack_troop_count = move_data.attack_troop_count;\n\n    // Default result\n    let mut result = AttackResult::default();\n\n    // Validation checks\n    let player_turn = game_state.current_player == player_state.player_id;\n    let owns_from = game_state.territories[from_territory_id].owner_id == player_state.player_id;\n    let doesnt_own_to = game_state.territories[to_territory_id].owner_id != player_state.player_id;\n    let territories_adjacent =\n        adjacency_map.are_adjacent(from_territory_id as Field, to_territory_id as Field);\n    let from_troops = game_state.territories[from_territory_id].troop_count;\n    let has_enough_troops = attack_troop_count > 0 & attack_troop_count < from_troops;\n\n    let valid_attack =\n        player_turn & owns_from & doesnt_own_to & territories_adjacent & has_enough_troops;\n\n    assert(valid_attack == true, \"attack should be valid\");\n\n    // The attack is valid, proceed with the battle\n    result.success = true;\n\n    // Determine number of dice\n    let attacker_dice = if attack_troop_count >= 3 {\n        3\n    } else {\n        attack_troop_count\n    };\n\n    let defender_troops = game_state.territories[to_territory_id].troop_count;\n    let defender_dice = if defender_troops >= 2 { 2 } else { 1 };\n\n    // Roll and sort dice\n    let defender_id = game_state.territories[to_territory_id].owner_id;\n    let nonce = move_data.dice_roll_seed;\n\n    let attacker_rolls = roll_dice(\n        player_state.encrypt_secret,\n        defender_id,\n        from_territory_id as Field,\n        to_territory_id as Field,\n        attacker_dice,\n        nonce,\n    );\n\n    // Simulate defender rolls (in real game, defender would use their own secret)\n    let defender_secret = poseidon2([player_state.encrypt_secret, defender_id], 2);\n\n    let defender_rolls = roll_dice(\n        defender_secret,\n        player_state.player_id,\n        to_territory_id as Field,\n        from_territory_id as Field,\n        defender_dice,\n        nonce,\n    );\n    println(f\"attacker roles: {attacker_rolls}\");\n    println(f\"defender roles: {defender_rolls}\");\n    let mut sorted_attacker = [0, 0, 0];\n    let mut sorted_defender = [0, 0, 0];\n\n    unsafe {\n        sorted_attacker = sort_dice(attacker_rolls, attacker_dice);\n        sorted_defender = sort_dice(defender_rolls, defender_dice);\n    }\n    // Sort dice in descending order\n\n    // Compare dice and compute casualties\n    let mut attacker_losses = 0;\n    let mut defender_losses = 0;\n    let compare_count = if defender_dice < attacker_dice {\n        defender_dice\n    } else {\n        attacker_dice\n    };\n\n    unsafe {\n        let result = calculate_losses(compare_count, sorted_attacker, sorted_defender);\n        attacker_losses = result.0;\n        defender_losses = result.1;\n    }\n    // Update result with battle outcome\n    result.attacker_losses = attacker_losses;\n    result.defender_losses = defender_losses;\n\n    // Update game state based on the outcome\n    let mut updated_game = game_state;\n    let mut updated_player = player_state;\n\n    // Check if the territory was conquered\n    let territory_conquered = defender_losses >= defender_troops;\n    result.territory_captured = territory_conquered;\n\n    if territory_conquered {\n        // Attacker conquers the territory\n        let remaining_attack_troops = attack_troop_count - attacker_losses;\n        updated_game.territories[to_territory_id].owner_id = player_state.player_id;\n        updated_game.territories[to_territory_id].troop_count = remaining_attack_troops;\n        updated_game.territories[from_territory_id].troop_count -=\n            (remaining_attack_troops + attacker_losses);\n\n        // Mark that player has conquered a territory this turn (for cards)\n        updated_player.has_conquered_territory = true;\n    } else {\n        // Defender keeps the territory with reduced troops\n        updated_game.territories[from_territory_id].troop_count -= attacker_losses;\n        updated_game.territories[to_territory_id].troop_count -= defender_losses;\n    }\n\n    // Check for win condition\n    updated_game = check_win_condition(updated_game);\n\n    (updated_game, updated_player, result)\n}\n\n#[export]\npub fn execute_fortify(\n    game_state: GameState,\n    player_state: PlayerState,\n    adjacency_map: AdjacencyMap,\n    move_data: FortifyMove,\n) -> (GameState, PlayerState, bool) {\n    let from_territory_id = move_data.from_territory_id as u32;\n    let to_territory_id = move_data.to_territory_id as u32;\n    let troop_count = move_data.troop_count;\n\n    // Validation checks\n    let player_turn = game_state.current_player == player_state.player_id;\n    let owns_from = game_state.territories[from_territory_id].owner_id == player_state.player_id;\n    let owns_to = game_state.territories[to_territory_id].owner_id == player_state.player_id;\n    let territories_adjacent =\n        adjacency_map.are_adjacent(from_territory_id as Field, to_territory_id as Field);\n    let from_troops = game_state.territories[from_territory_id].troop_count;\n    let has_enough_troops = troop_count > 0 & troop_count < from_troops;\n\n    let valid_fortify =\n        player_turn & owns_from & owns_to & territories_adjacent & has_enough_troops;\n\n    if valid_fortify {\n        // Update game state\n        let mut updated_game = game_state;\n\n        updated_game.territories[from_territory_id].troop_count -= troop_count;\n        updated_game.territories[to_territory_id].troop_count += troop_count;\n\n        (updated_game, player_state, true)\n    } else {\n        (game_state, player_state, false)\n    }\n}\n\n#[export]\npub fn check_win_condition(game_state: GameState) -> GameState {\n    let mut updated_game = game_state;\n    let territory_counts = count_player_territories(game_state);\n\n    // Check if any player owns all territories\n    for player_id in 1..=MAX_PLAYERS {\n        if territory_counts[player_id] as u32 == MAX_TERRITORIES {\n            updated_game.game_ended = true;\n            updated_game.winner = player_id as Field;\n        }\n    }\n\n    updated_game\n}\n\n// Count territories owned by each player\npub fn count_player_territories(game_state: GameState) -> [Field; MAX_PLAYERS + 1] {\n    let mut counts = [0; MAX_PLAYERS + 1];\n\n    for i in 0..MAX_TERRITORIES {\n        let owner = game_state.territories[i].owner_id;\n        if owner as u32 > 0 & owner as u32 <= MAX_PLAYERS {\n            let owner_idx = owner as u32;\n            counts[owner_idx] += 1;\n        }\n    }\n\n    counts\n}\n\n#[export]\npub fn end_turn(game_state: GameState) -> GameState {\n    // Ensure the game has not ended\n    assert(!game_state.game_ended, \"Game has already ended\");\n\n    let mut updated_game = game_state;\n\n    // Find the next active player\n    let current_player = game_state.current_player;\n    let mut next_player = current_player + 1;\n\n    // Wrap around to player 1 if we reach beyond max players\n    if next_player as u32 > MAX_PLAYERS {\n        next_player = 1;\n    }\n\n    // Update game state\n    updated_game.current_player = next_player;\n    updated_game.turn_count += 1;\n\n    updated_game\n}\n\npub fn execute_move(\n    game_state: GameState,\n    player_state: PlayerState,\n    adjacency_map: AdjacencyMap,\n    game_move: GameMove,\n) -> (GameState, PlayerState, bool) {\n    match game_move {\n        GameMove::PlaceTroops(move_data) => { place_troops(game_state, player_state, move_data) },\n        GameMove::Attack(move_data) => {\n            let (updated_game, updated_player, result) =\n                execute_attack(game_state, player_state, adjacency_map, move_data);\n            (updated_game, updated_player, result.success)\n        },\n        GameMove::Fortify(move_data) => {\n            execute_fortify(game_state, player_state, adjacency_map, move_data)\n        },\n        GameMove::EndTurn => {\n            if game_state.current_player == player_state.player_id {\n                let updated_game = end_turn(game_state);\n                (updated_game, player_state, true)\n            } else {\n                (game_state, player_state, false)\n            }\n        },\n        _ => (game_state, player_state, false),\n    }\n}\n\nunconstrained fn calculate_losses(\n    compare_count: u32,\n    sorted_attacker: [u32; 3],\n    sorted_defender: [u32; 3],\n) -> (u32, u32) {\n    let mut defender_losses = 0;\n    let mut attacker_losses = 0;\n    for i in 0..compare_count {\n        if sorted_attacker[i] > sorted_defender[i] {\n            defender_losses += 1;\n        } else {\n            attacker_losses += 1;\n        }\n    }\n    (attacker_losses, defender_losses)\n}\n","path":"/Users/satyam/web3/noir/Risk/game_circuit/src/game_mechanics.nr"}},"names":["execute_attack"],"brillig_names":["print_unconstrained","sort_dice","calculate_losses","directive_integer_quotient","directive_invert","directive_to_radix"]}