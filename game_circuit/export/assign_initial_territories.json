{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":7778114629262407561,"abi":{"parameters":[{"name":"game_state","type":{"kind":"struct","path":"common::GameState","fields":[{"name":"game_ended","type":{"kind":"boolean"}},{"name":"turn_count","type":{"kind":"field"}},{"name":"current_player","type":{"kind":"field"}},{"name":"territories","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"mpc_state","type":{"kind":"struct","path":"common::MPCState","fields":[{"name":"user_encrypt_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"user_mask_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"round_id","type":{"kind":"field"}}]}},{"name":"winner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"num_players","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"random_seed","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"common::GameState","fields":[{"name":"game_ended","type":{"kind":"boolean"}},{"name":"turn_count","type":{"kind":"field"}},{"name":"current_player","type":{"kind":"field"}},{"name":"territories","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"mpc_state","type":{"kind":"struct","path":"common::MPCState","fields":[{"name":"user_encrypt_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"user_mask_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"round_id","type":{"kind":"field"}}]}},{"name":"winner","type":{"kind":"field"}}]},"visibility":"private"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"15803065596631416538":{"error_kind":"string","string":"Invalid number of players"}}},"bytecode":"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","debug_symbols":"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","file_map":{"25":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"62":{"source":"use std::hash::poseidon2::Poseidon2::hash as poseidon2;\n\nuse crate::common::{AdjacencyMap, GameState, MPCState, PlayerState, Territory};\nuse crate::common::constants::{\n    INITIAL_TROOPS_PER_PLAYER, MAX_PLAYERS, MAX_TERRITORIES, MIN_REINFORCEMENTS,\n};\n\n#[export]\npub fn initialize_game_state(num_players: u32) -> GameState {\n    assert(num_players >= 2 & num_players <= MAX_PLAYERS, \"Invalid number of players\");\n\n    let mut game_state = GameState::default();\n\n    for i in 0..MAX_TERRITORIES {\n        let mut territory = Territory::default();\n        territory.id = i as Field;\n        game_state.territories[i] = territory;\n    }\n\n    game_state.game_ended = false;\n    game_state.turn_count = 0;\n    game_state.current_player = 1;\n    game_state.winner = 0;\n\n    game_state\n}\n\n#[export]\npub fn initialize_player_state(\n    player_id: Field,\n    encrypt_secret: Field,\n    mask_secret: Field,\n) -> PlayerState {\n    assert(player_id as u32 > 0 & player_id as u32 <= MAX_PLAYERS, \"Invalid player ID\");\n\n    // Validate secrets are non-zero\n    assert(encrypt_secret != 0, \"Encryption secret cannot be zero\");\n    assert(mask_secret != 0, \"Mask secret cannot be zero\");\n\n    let mut player_state = PlayerState::default();\n    player_state.player_id = player_id;\n    player_state.encrypt_secret = encrypt_secret;\n    player_state.mask_secret = mask_secret;\n    player_state.unallocated_troops = INITIAL_TROOPS_PER_PLAYER;\n    player_state.reinforcements = 0;\n    player_state.has_conquered_territory = false;\n\n    // Initialize territory visibility to false\n    for i in 0..MAX_TERRITORIES {\n        player_state.visible_territories[i] = false;\n    }\n\n    // Initialize territory view\n    for i in 0..MAX_TERRITORIES {\n        let mut territory = Territory::default();\n        territory.id = i as Field;\n        player_state.territories_view[i] = territory;\n    }\n\n    player_state\n}\n\n#[export]\npub fn create_risk_adjacency_map() -> AdjacencyMap {\n    let mut map = AdjacencyMap::default();\n\n    // Simple version of risk map with just 24 territories due to Noir bitshift constraint\n    // North America (9 territories)\n    map = map.add_adjacency(0, 1); // Alaska - Northwest Territory\n    map = map.add_adjacency(0, 3); // Alaska - Kamchatka (across the Bering Strait)\n    map = map.add_adjacency(1, 2); // Northwest Territory - Greenland\n    map = map.add_adjacency(1, 4); // Northwest Territory - Alberta\n    map = map.add_adjacency(2, 6); // Greenland - Quebec\n    map = map.add_adjacency(2, 14); // Greenland - Iceland\n    map = map.add_adjacency(3, 4); // Alberta - Ontario\n    map = map.add_adjacency(4, 5); // Ontario - Quebec\n    map = map.add_adjacency(4, 7); // Ontario - Eastern United States\n    map = map.add_adjacency(5, 7); // Quebec - Eastern United States\n    map = map.add_adjacency(6, 7); // Western United States - Eastern United States\n    map = map.add_adjacency(6, 8); // Western United States - Central America\n    map = map.add_adjacency(8, 9); // Central America - Venezuela\n\n    // South America (4 territories)\n    map = map.add_adjacency(9, 10); // Venezuela - Peru\n    map = map.add_adjacency(9, 11); // Venezuela - Brazil\n    map = map.add_adjacency(10, 11); // Peru - Brazil\n    map = map.add_adjacency(10, 12); // Peru - Argentina\n    map = map.add_adjacency(11, 12); // Brazil - Argentina\n    map = map.add_adjacency(11, 15); // Brazil - North Africa\n\n    // // Europe (7 territories)\n    map = map.add_adjacency(13, 14); // Great Britain - Iceland\n    map = map.add_adjacency(13, 15); // Great Britain - Western Europe\n    map = map.add_adjacency(13, 16); // Great Britain - Northern Europe\n    map = map.add_adjacency(13, 17); // Great Britain - Scandinavia\n    map = map.add_adjacency(14, 17); // Iceland - Scandinavia\n    map = map.add_adjacency(15, 16); // Western Europe - Northern Europe\n    map = map.add_adjacency(15, 18); // Western Europe - Southern Europe\n    map = map.add_adjacency(15, 21); // Western Europe - North Africa\n    map = map.add_adjacency(16, 17); // Northern Europe - Scandinavia\n    map = map.add_adjacency(16, 18); // Northern Europe - Southern Europe\n    map = map.add_adjacency(16, 19); // Northern Europe - Ukraine\n    map = map.add_adjacency(17, 19); // Scandinavia - Ukraine\n    map = map.add_adjacency(18, 19); // Southern Europe - Ukraine\n    map = map.add_adjacency(18, 21); // Southern Europe - North Africa\n    map = map.add_adjacency(18, 22); // Southern Europe - Egypt\n    // map = map.add_adjacency(18, 24); // Southern Europe - Middle East\n\n    // // Africa (6 territories)\n    map = map.add_adjacency(20, 21); // Congo - North Africa\n    map = map.add_adjacency(20, 22); // Congo - Egypt\n    map = map.add_adjacency(20, 23); // Congo - East Africa\n\n    map\n}\n\n#[export]\npub fn assign_initial_territories(\n    game_state: GameState,\n    num_players: u32,\n    random_seed: Field,\n) -> GameState {\n    assert(num_players >= 2 & num_players <= MAX_PLAYERS, \"Invalid number of players\");\n\n    let mut updated_state = game_state;\n\n    // Create deterministic \"random\" assignments based on the seed\n    for i in 0..MAX_TERRITORIES {\n        // Use poseidon hash to create pseudorandom values based on seed and territory ID\n        let hash_input = [random_seed, i as Field];\n        let rand_value = poseidon2(hash_input, 2);\n\n        // Assign to player 1 through num_players\n        let player = (rand_value as u32 % num_players) + 1;\n\n        // Update the game state\n        updated_state.territories[i].owner_id = player as Field;\n        updated_state.territories[i].troop_count = 1; // Start with 1 troop per territory\n    }\n\n    updated_state\n}\n\n#[export]\npub fn commit_to_user_secrets(\n    game_state: GameState,\n    encrypt_secret: Field,\n    mask_secret: Field,\n    player_id: Field,\n) -> GameState {\n    assert(player_id as u32 > 0 & player_id as u32 <= MAX_PLAYERS, \"Invalid player ID\");\n    assert(encrypt_secret != 0, \"Encryption secret cannot be zero\");\n    assert(mask_secret != 0, \"Mask secret cannot be zero\");\n\n    let mut updated = game_state;\n\n    // Hash the secrets to create commitments\n    let encrypt_hash = poseidon2([encrypt_secret, player_id], 2);\n    let mask_hash = poseidon2([mask_secret, player_id], 2);\n\n    // Store the commitments\n    let idx = (player_id - 1) as u32;\n    updated.mpc_state.user_encrypt_secret_hashes[idx] = encrypt_hash;\n    updated.mpc_state.user_mask_secret_hashes[idx] = mask_hash;\n\n    updated\n}\n\n#[export]\npub fn register_all_players(\n    game_state: GameState,\n    player_secrets: [(Field, Field); MAX_PLAYERS],\n) -> GameState {\n    let mut updated = game_state;\n\n    for i in 0..MAX_PLAYERS {\n        let player_id = (i + 1) as Field;\n        let (encrypt_secret, mask_secret) = player_secrets[i];\n\n        // Only process valid players with non-zero secrets\n        if (encrypt_secret as u32 != 0) & (mask_secret as u32 != 0) {\n            updated = commit_to_user_secrets(updated, encrypt_secret, mask_secret, player_id);\n        }\n    }\n\n    updated\n}\n\n#[export]\npub fn count_player_territories(game_state: GameState) -> [Field; MAX_PLAYERS + 1] {\n    let mut counts = [0; MAX_PLAYERS + 1];\n\n    for i in 0..MAX_TERRITORIES {\n        let owner = game_state.territories[i].owner_id;\n        if owner as u32 > 0 & owner as u32 <= MAX_PLAYERS {\n            let owner_idx = owner as u32;\n            counts[owner_idx] += 1;\n        }\n    }\n\n    counts\n}\n\npub fn calculate_reinforcements(game_state: GameState, player_id: Field) -> Field {\n    let territory_counts = count_player_territories(game_state);\n    let player_idx = player_id as u32;\n    let player_territory_count = territory_counts[player_idx];\n\n    // Basic rule: Number of territories divided by 3, with a minimum of 3\n    let reinforcements = player_territory_count / 3;\n\n    if reinforcements as u32 < MIN_REINFORCEMENTS {\n        MIN_REINFORCEMENTS as Field\n    } else {\n        reinforcements\n    }\n}\n\npub fn get_turn_reinforcements(game_state: GameState, player_state: PlayerState) -> PlayerState {\n    assert(game_state.current_player == player_state.player_id, \"Not this player's turn\");\n\n    let reinforcements = calculate_reinforcements(game_state, player_state.player_id);\n\n    // Update player state with new reinforcements\n    let mut updated_player = player_state;\n    updated_player.reinforcements = reinforcements as u32;\n    updated_player.unallocated_troops += reinforcements as u32;\n\n    updated_player\n}\n","path":"/Users/satyam/web3/noir/Risk/game_circuit/src/game_initialization.nr"}},"names":["assign_initial_territories"],"brillig_names":["directive_integer_quotient","directive_invert"]}