{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":12205678467503468677,"abi":{"parameters":[{"name":"game_state","type":{"kind":"struct","path":"common::GameState","fields":[{"name":"game_ended","type":{"kind":"boolean"}},{"name":"turn_count","type":{"kind":"field"}},{"name":"current_player","type":{"kind":"field"}},{"name":"territories","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"mpc_state","type":{"kind":"struct","path":"common::MPCState","fields":[{"name":"user_encrypt_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"user_mask_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"round_id","type":{"kind":"field"}}]}},{"name":"winner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"common::GameState","fields":[{"name":"game_ended","type":{"kind":"boolean"}},{"name":"turn_count","type":{"kind":"field"}},{"name":"current_player","type":{"kind":"field"}},{"name":"territories","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"mpc_state","type":{"kind":"struct","path":"common::MPCState","fields":[{"name":"user_encrypt_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"user_mask_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"round_id","type":{"kind":"field"}}]}},{"name":"winner","type":{"kind":"field"}}]},"visibility":"private"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"63":{"source":"// game_mechanics.nr\nuse dep::std;\nuse std::hash::poseidon2::Poseidon2::hash as poseidon2;\n\nuse crate::common::{\n    AdjacencyMap, AttackMove, AttackResult, FortifyMove, GameMove, GameState, PlayerState,\n    Territory, TroopPlacementMove,\n};\nuse crate::common::constants::{MAX_PLAYERS, MAX_TERRITORIES};\n\n// Place troops on a territory\n#[export]\npub fn place_troops(\n    game_state: GameState,\n    player_state: PlayerState,\n    move_data: TroopPlacementMove,\n) -> (GameState, PlayerState, bool) {\n    let territory_id = move_data.territory_id;\n    let troop_count = move_data.troop_count;\n\n    // Validation checks\n    let player_turn = game_state.current_player == player_state.player_id;\n    let owns_territory =\n        game_state.territories[territory_id as u32].owner_id == player_state.player_id;\n    let has_enough_troops = troop_count > 0 & troop_count <= player_state.unallocated_troops;\n\n    let valid_move = player_turn & owns_territory & has_enough_troops;\n\n    if valid_move {\n        // Update game and player state\n        let mut updated_game = game_state;\n        let mut updated_player = player_state;\n\n        updated_game.territories[territory_id as u32].troop_count += troop_count;\n        updated_player.unallocated_troops -= troop_count;\n\n        (updated_game, updated_player, true)\n    } else {\n        (game_state, player_state, false)\n    }\n}\n\n// Generate a dice roll using player secrets for randomness\nfn roll_dice(\n    attacker_secret: Field,\n    defender_id: Field,\n    from_territory: Field,\n    to_territory: Field,\n    num_dice: u32,\n    nonce: Field,\n) -> [u32; 3] {\n    // Return up to 3 dice values\n    let mut dice_values = [0; 3];\n\n    for i in 0..3 {\n        if i < num_dice {\n            // Create a unique seed for each die\n            let hash_input =\n                [attacker_secret, defender_id, from_territory, to_territory, i as Field, nonce];\n\n            let seed = poseidon2(hash_input, 6);\n\n            // Convert to a number between 1-6\n            dice_values[i] = ((seed as u32 % 6) + 1) as u32;\n        }\n    }\n\n    dice_values\n}\n\n// Sort an array of dice values in descending order\nunconstrained fn sort_dice(dice: [u32; 3], count: u32) -> [u32; 3] {\n    let mut sorted = dice;\n\n    // Simple bubble sort\n    for i in 0..count {\n        for j in 0..(count - i - 1) {\n            if sorted[j] < sorted[j + 1] {\n                let temp = sorted[j];\n                sorted[j] = sorted[j + 1];\n                sorted[j + 1] = temp;\n            }\n        }\n    }\n\n    sorted\n}\n\n#[export]\npub fn execute_attack(\n    game_state: GameState,\n    player_state: PlayerState,\n    adjacency_map: AdjacencyMap,\n    move_data: AttackMove,\n) -> (GameState, PlayerState, AttackResult) {\n    let from_territory_id = move_data.from_territory_id as u32;\n    let to_territory_id = move_data.to_territory_id as u32;\n    let attack_troop_count = move_data.attack_troop_count;\n\n    // Default result\n    let mut result = AttackResult::default();\n\n    // Validation checks\n    let player_turn = game_state.current_player == player_state.player_id;\n    let owns_from = game_state.territories[from_territory_id].owner_id == player_state.player_id;\n    let doesnt_own_to = game_state.territories[to_territory_id].owner_id != player_state.player_id;\n    let territories_adjacent =\n        adjacency_map.are_adjacent(from_territory_id as Field, to_territory_id as Field);\n    let from_troops = game_state.territories[from_territory_id].troop_count;\n    let has_enough_troops = attack_troop_count > 0 & attack_troop_count < from_troops;\n\n    let valid_attack =\n        player_turn & owns_from & doesnt_own_to & territories_adjacent & has_enough_troops;\n\n    assert(valid_attack == true, \"attack should be valid\");\n\n    // The attack is valid, proceed with the battle\n    result.success = true;\n\n    // Determine number of dice\n    let attacker_dice = if attack_troop_count >= 3 {\n        3\n    } else {\n        attack_troop_count\n    };\n\n    let defender_troops = game_state.territories[to_territory_id].troop_count;\n    let defender_dice = if defender_troops >= 2 { 2 } else { 1 };\n\n    // Roll and sort dice\n    let defender_id = game_state.territories[to_territory_id].owner_id;\n    let nonce = move_data.dice_roll_seed;\n\n    let attacker_rolls = roll_dice(\n        player_state.encrypt_secret,\n        defender_id,\n        from_territory_id as Field,\n        to_territory_id as Field,\n        attacker_dice,\n        nonce,\n    );\n\n    // Simulate defender rolls (in real game, defender would use their own secret)\n    let defender_secret = poseidon2([player_state.encrypt_secret, defender_id], 2);\n\n    let defender_rolls = roll_dice(\n        defender_secret,\n        player_state.player_id,\n        to_territory_id as Field,\n        from_territory_id as Field,\n        defender_dice,\n        nonce,\n    );\n    println(f\"attacker roles: {attacker_rolls}\");\n    println(f\"defender roles: {defender_rolls}\");\n    let mut sorted_attacker = [0, 0, 0];\n    let mut sorted_defender = [0, 0, 0];\n\n    unsafe {\n        sorted_attacker = sort_dice(attacker_rolls, attacker_dice);\n        sorted_defender = sort_dice(defender_rolls, defender_dice);\n    }\n    // Sort dice in descending order\n\n    // Compare dice and compute casualties\n    let mut attacker_losses = 0;\n    let mut defender_losses = 0;\n    let compare_count = if defender_dice < attacker_dice {\n        defender_dice\n    } else {\n        attacker_dice\n    };\n\n    unsafe {\n        let result = calculate_losses(compare_count, sorted_attacker, sorted_defender);\n        attacker_losses = result.0;\n        defender_losses = result.1;\n    }\n    // Update result with battle outcome\n    result.attacker_losses = attacker_losses;\n    result.defender_losses = defender_losses;\n\n    // Update game state based on the outcome\n    let mut updated_game = game_state;\n    let mut updated_player = player_state;\n\n    // Check if the territory was conquered\n    let territory_conquered = defender_losses >= defender_troops;\n    result.territory_captured = territory_conquered;\n\n    if territory_conquered {\n        // Attacker conquers the territory\n        let remaining_attack_troops = attack_troop_count - attacker_losses;\n        updated_game.territories[to_territory_id].owner_id = player_state.player_id;\n        updated_game.territories[to_territory_id].troop_count = remaining_attack_troops;\n        updated_game.territories[from_territory_id].troop_count -=\n            (remaining_attack_troops + attacker_losses);\n\n        // Mark that player has conquered a territory this turn (for cards)\n        updated_player.has_conquered_territory = true;\n    } else {\n        // Defender keeps the territory with reduced troops\n        updated_game.territories[from_territory_id].troop_count -= attacker_losses;\n        updated_game.territories[to_territory_id].troop_count -= defender_losses;\n    }\n\n    // Check for win condition\n    updated_game = check_win_condition(updated_game);\n\n    (updated_game, updated_player, result)\n}\n\n#[export]\npub fn execute_fortify(\n    game_state: GameState,\n    player_state: PlayerState,\n    adjacency_map: AdjacencyMap,\n    move_data: FortifyMove,\n) -> (GameState, PlayerState, bool) {\n    let from_territory_id = move_data.from_territory_id as u32;\n    let to_territory_id = move_data.to_territory_id as u32;\n    let troop_count = move_data.troop_count;\n\n    // Validation checks\n    let player_turn = game_state.current_player == player_state.player_id;\n    let owns_from = game_state.territories[from_territory_id].owner_id == player_state.player_id;\n    let owns_to = game_state.territories[to_territory_id].owner_id == player_state.player_id;\n    let territories_adjacent =\n        adjacency_map.are_adjacent(from_territory_id as Field, to_territory_id as Field);\n    let from_troops = game_state.territories[from_territory_id].troop_count;\n    let has_enough_troops = troop_count > 0 & troop_count < from_troops;\n\n    let valid_fortify =\n        player_turn & owns_from & owns_to & territories_adjacent & has_enough_troops;\n\n    if valid_fortify {\n        // Update game state\n        let mut updated_game = game_state;\n\n        updated_game.territories[from_territory_id].troop_count -= troop_count;\n        updated_game.territories[to_territory_id].troop_count += troop_count;\n\n        (updated_game, player_state, true)\n    } else {\n        (game_state, player_state, false)\n    }\n}\n\n#[export]\npub fn check_win_condition(game_state: GameState) -> GameState {\n    let mut updated_game = game_state;\n    let territory_counts = count_player_territories(game_state);\n\n    // Check if any player owns all territories\n    for player_id in 1..=MAX_PLAYERS {\n        if territory_counts[player_id] as u32 == MAX_TERRITORIES {\n            updated_game.game_ended = true;\n            updated_game.winner = player_id as Field;\n        }\n    }\n\n    updated_game\n}\n\n// Count territories owned by each player\npub fn count_player_territories(game_state: GameState) -> [Field; MAX_PLAYERS + 1] {\n    let mut counts = [0; MAX_PLAYERS + 1];\n\n    for i in 0..MAX_TERRITORIES {\n        let owner = game_state.territories[i].owner_id;\n        if owner as u32 > 0 & owner as u32 <= MAX_PLAYERS {\n            let owner_idx = owner as u32;\n            counts[owner_idx] += 1;\n        }\n    }\n\n    counts\n}\n\n#[export]\npub fn end_turn(game_state: GameState) -> GameState {\n    // Ensure the game has not ended\n    assert(!game_state.game_ended, \"Game has already ended\");\n\n    let mut updated_game = game_state;\n\n    // Find the next active player\n    let current_player = game_state.current_player;\n    let mut next_player = current_player + 1;\n\n    // Wrap around to player 1 if we reach beyond max players\n    if next_player as u32 > MAX_PLAYERS {\n        next_player = 1;\n    }\n\n    // Update game state\n    updated_game.current_player = next_player;\n    updated_game.turn_count += 1;\n\n    updated_game\n}\n\npub fn execute_move(\n    game_state: GameState,\n    player_state: PlayerState,\n    adjacency_map: AdjacencyMap,\n    game_move: GameMove,\n) -> (GameState, PlayerState, bool) {\n    match game_move {\n        GameMove::PlaceTroops(move_data) => { place_troops(game_state, player_state, move_data) },\n        GameMove::Attack(move_data) => {\n            let (updated_game, updated_player, result) =\n                execute_attack(game_state, player_state, adjacency_map, move_data);\n            (updated_game, updated_player, result.success)\n        },\n        GameMove::Fortify(move_data) => {\n            execute_fortify(game_state, player_state, adjacency_map, move_data)\n        },\n        GameMove::EndTurn => {\n            if game_state.current_player == player_state.player_id {\n                let updated_game = end_turn(game_state);\n                (updated_game, player_state, true)\n            } else {\n                (game_state, player_state, false)\n            }\n        },\n        _ => (game_state, player_state, false),\n    }\n}\n\nunconstrained fn calculate_losses(\n    compare_count: u32,\n    sorted_attacker: [u32; 3],\n    sorted_defender: [u32; 3],\n) -> (u32, u32) {\n    let mut defender_losses = 0;\n    let mut attacker_losses = 0;\n    for i in 0..compare_count {\n        if sorted_attacker[i] > sorted_defender[i] {\n            defender_losses += 1;\n        } else {\n            attacker_losses += 1;\n        }\n    }\n    (attacker_losses, defender_losses)\n}\n","path":"/Users/satyam/web3/noir/Risk/game_circuit/src/game_mechanics.nr"}},"names":["check_win_condition"],"brillig_names":["directive_integer_quotient","directive_invert"]}