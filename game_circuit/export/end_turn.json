{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":2151931090077613597,"abi":{"parameters":[{"name":"game_state","type":{"kind":"struct","path":"common::GameState","fields":[{"name":"game_ended","type":{"kind":"boolean"}},{"name":"turn_count","type":{"kind":"field"}},{"name":"current_player","type":{"kind":"field"}},{"name":"territories","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"mpc_state","type":{"kind":"struct","path":"common::MPCState","fields":[{"name":"user_encrypt_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"user_mask_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"round_id","type":{"kind":"field"}}]}},{"name":"winner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"common::GameState","fields":[{"name":"game_ended","type":{"kind":"boolean"}},{"name":"turn_count","type":{"kind":"field"}},{"name":"current_player","type":{"kind":"field"}},{"name":"territories","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"mpc_state","type":{"kind":"struct","path":"common::MPCState","fields":[{"name":"user_encrypt_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"user_mask_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"round_id","type":{"kind":"field"}}]}},{"name":"winner","type":{"kind":"field"}}]},"visibility":"private"},"error_types":{"3302949731092695616":{"error_kind":"string","string":"Game has already ended"}}},"bytecode":"H4sIAAAAAAAA/9Wc+XJURRSH70wSzSIIMhFE0QEURUFmTWZEcVA0ihtx34WRibvgiruIO+77rpgQk8fwKSz/8lm8H+kubt10qCLzu1WcrurqmTOTk/667/R6zslFc2k2zgfc61yce1zZF+diStYfkA0FZEsDsuUBWSEgWxmQrQ7I1gRkxYBsfUC2ISDbGJBtCsi2BGSVgKwekDUCsq0B2baAbHtAtiMgGwvIdjpZMuVc2XJlqbtUFuoq9To9+Wh+Utc7L26DdOpSd9m/SLbFpCunolRH88F/KdlUoPN7MmzEammkVuuMVjrlanlPqdJsN+qlWr090ig3yvVGfW+lUa12GrXGaLPdHC01y7VqpzxRb1YmnK7J7nVVna7SlJCx17VnLpqf0g9lt/WeDNR7sTqT9T2aZYVRnl/gwVqs/qPCDpwW8mbVhtPRwiPcYvVP69owE+4px73Qs3OyyetV9vdfwjZMDs7oXRvnk5nxToFB0c9KlUB1M5nxZlw56xvEN+BMdHxU9jK+VExVqifDRux2xpsR1ms2o85VL7vGI+2g5FNe3M85IfPt0ak9AeUTvydlX98h5s6qr3uEzHdGNp7vXiHzXUaY+4TMdxthPk3IfI8R5tOFzPcaYe4XMt9nhHlAyHy/EeZBIfMDRpiHhMwPGmE+Q8j8kBHmJULmh40wLxUyP2KE+Uwh824jzMuEzHuMMC8XMreNMJ8lZH7UCPMKIfNeI8wFIXPHCPOwkHnCCPPZQubHjDCvFDI/boR5lZD5CSPM5wiZnzTCvFrI/JQR5nOFzE8bYT5PyPyMEeY1QuZnjTCfL2TeZ4T5AiHzfiPMRSHzc0aY1wqZnzfCvE7I/IIR5vVC5heNMF8oZH7JCPNFQuaXjTBvEDIfMMJ8sZD5FSPMlwiZXzXCvFHI/JoR5kuFzK8bYb5MyPyGEeZNQuY3jTBvFjK/ZYT5ciHz20aYtwiZDxphLgmZ3zHCXBYyHzLCXBEyv2uEuSpkfs8Ic03I/L4R5rqQ+QMjzCNC5g+NMI8KmT8ywtwQMn9shLkpZD5shPkKIfMnRpi3Cpk/NcJ8pZD5MyPMVwmZPzfCvE3I/IUR5quFzF8aYW4Jmb8ywrxdyPy1EeZrhMzfGGG+Vsj8rRHmHULm74wwXydk/t4I8/VC5h+MMI8JmX80wnyDkPknI8w3Cpl/NsK8U8j8ixHmm4TMvxphvlnI/JsR5luEzL8bYb5VyPyHEebbhMxHjDDvEjL/KWYeT3DnHDsxoYiRRMwgYugQU4YYK8QcIQYHMSmI0UDMAnz48WlfFs2FO8YHGJ9YfETxmcSHEJ86fMzwucIHCZ8cfFTw2cCHAZv+YjQXFHBdNBe+GBtZbEaxocSmEBs7bM6wwcImCRsdbFaw4cCmARjuvLkD5k6UO0LuzLhD4k6FOwbO3DmD5kyWM0rO7DjD8mc67PnZA7MnZI/EnoE1NGtK1lisOZiDmZMYoxmz+A3zTO9KtON4oiT+GbHAiI1FrChiJxFLiNg6xJoh9gqxSIjNQawKYjcQy2B3nPF1b8cZX2h8g/GVxXcUX0p8C/G1w/cMXyx8k/DVwXcFX479ccbWH9t3bMGxjcZWGNtZbEmxrcTWENs7bNGwzcJWCdsdbFkOxhlbh0Nx5i6cu2HuSrk75C6NuyXuWrh74Cyes2nOajm75CyPsy3Oejj74CyAvTF7RfZO7CVYW7PWZO3FWoS5mbmKsZux7EicedaTkVxXubJ1+O9/x/b9s9nL/e+135UDrhx0pY+T2HLvS92litc/lI3+YzGc0mkw8Xoo9Znn7w38XW6B9/lUeaLvnij675LAZ17nClcm6+s5BlLlcEKvMiad11/IRn+wr4YTrwspzmR7t0R18Pp8vM++aH7Kpz7z303/ZnL6+s0LEd4T+F8++WemkJD59vwfknKff79fAAA=","debug_symbols":"ndJNCoMwEAXgu8zaRfNjUr1KKRI1SiAkEmOhiHdvlAoiheLs5s3jm9XM0Op66ivjOj9C+ZjB+kZF411KM1C+7cZBuTWOUYUIZcFJkYF27TpysmTQGauhFGx5ZkDzn0YSvhvJ6NkIhJEIc0eY4rphN4QhCEMRhiEM/2u4OJscYQTCyKsmhToYa01fHb89rV8qGFVb/Y3d5JpDG9/D3ux+CL7R7RT0emnr0vkP","file_map":{"63":{"source":"// game_mechanics.nr\nuse dep::std;\nuse std::hash::poseidon2::Poseidon2::hash as poseidon2;\n\nuse crate::common::{\n    AdjacencyMap, AttackMove, AttackResult, FortifyMove, GameMove, GameState, PlayerState,\n    Territory, TroopPlacementMove,\n};\nuse crate::common::constants::{MAX_PLAYERS, MAX_TERRITORIES};\n\n// Place troops on a territory\n#[export]\npub fn place_troops(\n    game_state: GameState,\n    player_state: PlayerState,\n    move_data: TroopPlacementMove,\n) -> (GameState, PlayerState, bool) {\n    let territory_id = move_data.territory_id;\n    let troop_count = move_data.troop_count;\n\n    // Validation checks\n    let player_turn = game_state.current_player == player_state.player_id;\n    let owns_territory =\n        game_state.territories[territory_id as u32].owner_id == player_state.player_id;\n    let has_enough_troops = troop_count > 0 & troop_count <= player_state.unallocated_troops;\n\n    let valid_move = player_turn & owns_territory & has_enough_troops;\n\n    if valid_move {\n        // Update game and player state\n        let mut updated_game = game_state;\n        let mut updated_player = player_state;\n\n        updated_game.territories[territory_id as u32].troop_count += troop_count;\n        updated_player.unallocated_troops -= troop_count;\n\n        (updated_game, updated_player, true)\n    } else {\n        (game_state, player_state, false)\n    }\n}\n\n// Generate a dice roll using player secrets for randomness\nfn roll_dice(\n    attacker_secret: Field,\n    defender_id: Field,\n    from_territory: Field,\n    to_territory: Field,\n    num_dice: u32,\n    nonce: Field,\n) -> [u32; 3] {\n    // Return up to 3 dice values\n    let mut dice_values = [0; 3];\n\n    for i in 0..3 {\n        if i < num_dice {\n            // Create a unique seed for each die\n            let hash_input =\n                [attacker_secret, defender_id, from_territory, to_territory, i as Field, nonce];\n\n            let seed = poseidon2(hash_input, 6);\n\n            // Convert to a number between 1-6\n            dice_values[i] = ((seed as u32 % 6) + 1) as u32;\n        }\n    }\n\n    dice_values\n}\n\n// Sort an array of dice values in descending order\nunconstrained fn sort_dice(dice: [u32; 3], count: u32) -> [u32; 3] {\n    let mut sorted = dice;\n\n    // Simple bubble sort\n    for i in 0..count {\n        for j in 0..(count - i - 1) {\n            if sorted[j] < sorted[j + 1] {\n                let temp = sorted[j];\n                sorted[j] = sorted[j + 1];\n                sorted[j + 1] = temp;\n            }\n        }\n    }\n\n    sorted\n}\n\n#[export]\npub fn execute_attack(\n    game_state: GameState,\n    player_state: PlayerState,\n    adjacency_map: AdjacencyMap,\n    move_data: AttackMove,\n) -> (GameState, PlayerState, AttackResult) {\n    let from_territory_id = move_data.from_territory_id as u32;\n    let to_territory_id = move_data.to_territory_id as u32;\n    let attack_troop_count = move_data.attack_troop_count;\n\n    // Default result\n    let mut result = AttackResult::default();\n\n    // Validation checks\n    let player_turn = game_state.current_player == player_state.player_id;\n    let owns_from = game_state.territories[from_territory_id].owner_id == player_state.player_id;\n    let doesnt_own_to = game_state.territories[to_territory_id].owner_id != player_state.player_id;\n    let territories_adjacent =\n        adjacency_map.are_adjacent(from_territory_id as Field, to_territory_id as Field);\n    let from_troops = game_state.territories[from_territory_id].troop_count;\n    let has_enough_troops = attack_troop_count > 0 & attack_troop_count < from_troops;\n\n    let valid_attack =\n        player_turn & owns_from & doesnt_own_to & territories_adjacent & has_enough_troops;\n\n    assert(valid_attack == true, \"attack should be valid\");\n\n    // The attack is valid, proceed with the battle\n    result.success = true;\n\n    // Determine number of dice\n    let attacker_dice = if attack_troop_count >= 3 {\n        3\n    } else {\n        attack_troop_count\n    };\n\n    let defender_troops = game_state.territories[to_territory_id].troop_count;\n    let defender_dice = if defender_troops >= 2 { 2 } else { 1 };\n\n    // Roll and sort dice\n    let defender_id = game_state.territories[to_territory_id].owner_id;\n    let nonce = move_data.dice_roll_seed;\n\n    let attacker_rolls = roll_dice(\n        player_state.encrypt_secret,\n        defender_id,\n        from_territory_id as Field,\n        to_territory_id as Field,\n        attacker_dice,\n        nonce,\n    );\n\n    // Simulate defender rolls (in real game, defender would use their own secret)\n    let defender_secret = poseidon2([player_state.encrypt_secret, defender_id], 2);\n\n    let defender_rolls = roll_dice(\n        defender_secret,\n        player_state.player_id,\n        to_territory_id as Field,\n        from_territory_id as Field,\n        defender_dice,\n        nonce,\n    );\n    println(f\"attacker roles: {attacker_rolls}\");\n    println(f\"defender roles: {defender_rolls}\");\n    let mut sorted_attacker = [0, 0, 0];\n    let mut sorted_defender = [0, 0, 0];\n\n    unsafe {\n        sorted_attacker = sort_dice(attacker_rolls, attacker_dice);\n        sorted_defender = sort_dice(defender_rolls, defender_dice);\n    }\n    // Sort dice in descending order\n\n    // Compare dice and compute casualties\n    let mut attacker_losses = 0;\n    let mut defender_losses = 0;\n    let compare_count = if defender_dice < attacker_dice {\n        defender_dice\n    } else {\n        attacker_dice\n    };\n\n    unsafe {\n        let result = calculate_losses(compare_count, sorted_attacker, sorted_defender);\n        attacker_losses = result.0;\n        defender_losses = result.1;\n    }\n    // Update result with battle outcome\n    result.attacker_losses = attacker_losses;\n    result.defender_losses = defender_losses;\n\n    // Update game state based on the outcome\n    let mut updated_game = game_state;\n    let mut updated_player = player_state;\n\n    // Check if the territory was conquered\n    let territory_conquered = defender_losses >= defender_troops;\n    result.territory_captured = territory_conquered;\n\n    if territory_conquered {\n        // Attacker conquers the territory\n        let remaining_attack_troops = attack_troop_count - attacker_losses;\n        updated_game.territories[to_territory_id].owner_id = player_state.player_id;\n        updated_game.territories[to_territory_id].troop_count = remaining_attack_troops;\n        updated_game.territories[from_territory_id].troop_count -=\n            (remaining_attack_troops + attacker_losses);\n\n        // Mark that player has conquered a territory this turn (for cards)\n        updated_player.has_conquered_territory = true;\n    } else {\n        // Defender keeps the territory with reduced troops\n        updated_game.territories[from_territory_id].troop_count -= attacker_losses;\n        updated_game.territories[to_territory_id].troop_count -= defender_losses;\n    }\n\n    // Check for win condition\n    updated_game = check_win_condition(updated_game);\n\n    (updated_game, updated_player, result)\n}\n\n#[export]\npub fn execute_fortify(\n    game_state: GameState,\n    player_state: PlayerState,\n    adjacency_map: AdjacencyMap,\n    move_data: FortifyMove,\n) -> (GameState, PlayerState, bool) {\n    let from_territory_id = move_data.from_territory_id as u32;\n    let to_territory_id = move_data.to_territory_id as u32;\n    let troop_count = move_data.troop_count;\n\n    // Validation checks\n    let player_turn = game_state.current_player == player_state.player_id;\n    let owns_from = game_state.territories[from_territory_id].owner_id == player_state.player_id;\n    let owns_to = game_state.territories[to_territory_id].owner_id == player_state.player_id;\n    let territories_adjacent =\n        adjacency_map.are_adjacent(from_territory_id as Field, to_territory_id as Field);\n    let from_troops = game_state.territories[from_territory_id].troop_count;\n    let has_enough_troops = troop_count > 0 & troop_count < from_troops;\n\n    let valid_fortify =\n        player_turn & owns_from & owns_to & territories_adjacent & has_enough_troops;\n\n    if valid_fortify {\n        // Update game state\n        let mut updated_game = game_state;\n\n        updated_game.territories[from_territory_id].troop_count -= troop_count;\n        updated_game.territories[to_territory_id].troop_count += troop_count;\n\n        (updated_game, player_state, true)\n    } else {\n        (game_state, player_state, false)\n    }\n}\n\n#[export]\npub fn check_win_condition(game_state: GameState) -> GameState {\n    let mut updated_game = game_state;\n    let territory_counts = count_player_territories(game_state);\n\n    // Check if any player owns all territories\n    for player_id in 1..=MAX_PLAYERS {\n        if territory_counts[player_id] as u32 == MAX_TERRITORIES {\n            updated_game.game_ended = true;\n            updated_game.winner = player_id as Field;\n        }\n    }\n\n    updated_game\n}\n\n// Count territories owned by each player\npub fn count_player_territories(game_state: GameState) -> [Field; MAX_PLAYERS + 1] {\n    let mut counts = [0; MAX_PLAYERS + 1];\n\n    for i in 0..MAX_TERRITORIES {\n        let owner = game_state.territories[i].owner_id;\n        if owner as u32 > 0 & owner as u32 <= MAX_PLAYERS {\n            let owner_idx = owner as u32;\n            counts[owner_idx] += 1;\n        }\n    }\n\n    counts\n}\n\n#[export]\npub fn end_turn(game_state: GameState) -> GameState {\n    // Ensure the game has not ended\n    assert(!game_state.game_ended, \"Game has already ended\");\n\n    let mut updated_game = game_state;\n\n    // Find the next active player\n    let current_player = game_state.current_player;\n    let mut next_player = current_player + 1;\n\n    // Wrap around to player 1 if we reach beyond max players\n    if next_player as u32 > MAX_PLAYERS {\n        next_player = 1;\n    }\n\n    // Update game state\n    updated_game.current_player = next_player;\n    updated_game.turn_count += 1;\n\n    updated_game\n}\n\npub fn execute_move(\n    game_state: GameState,\n    player_state: PlayerState,\n    adjacency_map: AdjacencyMap,\n    game_move: GameMove,\n) -> (GameState, PlayerState, bool) {\n    match game_move {\n        GameMove::PlaceTroops(move_data) => { place_troops(game_state, player_state, move_data) },\n        GameMove::Attack(move_data) => {\n            let (updated_game, updated_player, result) =\n                execute_attack(game_state, player_state, adjacency_map, move_data);\n            (updated_game, updated_player, result.success)\n        },\n        GameMove::Fortify(move_data) => {\n            execute_fortify(game_state, player_state, adjacency_map, move_data)\n        },\n        GameMove::EndTurn => {\n            if game_state.current_player == player_state.player_id {\n                let updated_game = end_turn(game_state);\n                (updated_game, player_state, true)\n            } else {\n                (game_state, player_state, false)\n            }\n        },\n        _ => (game_state, player_state, false),\n    }\n}\n\nunconstrained fn calculate_losses(\n    compare_count: u32,\n    sorted_attacker: [u32; 3],\n    sorted_defender: [u32; 3],\n) -> (u32, u32) {\n    let mut defender_losses = 0;\n    let mut attacker_losses = 0;\n    for i in 0..compare_count {\n        if sorted_attacker[i] > sorted_defender[i] {\n            defender_losses += 1;\n        } else {\n            attacker_losses += 1;\n        }\n    }\n    (attacker_losses, defender_losses)\n}\n","path":"/Users/satyam/web3/noir/Risk/game_circuit/src/game_mechanics.nr"}},"names":["end_turn"],"brillig_names":["directive_integer_quotient","directive_invert"]}