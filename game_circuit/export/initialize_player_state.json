{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":5401707750402852651,"abi":{"parameters":[{"name":"player_id","type":{"kind":"field"},"visibility":"private"},{"name":"encrypt_secret","type":{"kind":"field"},"visibility":"private"},{"name":"mask_secret","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"common::PlayerState","fields":[{"name":"player_id","type":{"kind":"field"}},{"name":"encrypt_secret","type":{"kind":"field"}},{"name":"mask_secret","type":{"kind":"field"}},{"name":"visible_territories","type":{"kind":"array","length":24,"type":{"kind":"boolean"}}},{"name":"territories_view","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"unallocated_troops","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"reinforcements","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"has_conquered_territory","type":{"kind":"boolean"}}]},"visibility":"private"},"error_types":{"6400654836729835912":{"error_kind":"string","string":"Invalid player ID"},"9731500601468557507":{"error_kind":"string","string":"Mask secret cannot be zero"},"9983489688954325393":{"error_kind":"string","string":"Encryption secret cannot be zero"}}},"bytecode":"H4sIAAAAAAAA/9WcyXLTQBCGx3aALITVYV/MvoPkJZYhQNj3fd+JiQIJIesNHgCK4sKNV+DIK8CJM3duPABXTvhPZkAl26lK3J3KP1WqcSSl/c3f45E0Pa2EmSzjle2N/dxk66SpLglbd9vaa6z4gra8GriN2vbdh6gW/bYecIKkbI0DP2P7cFImBpVSFDHndebzYTEb+jm/x8uWykHByxfKnYEf+IWg0JsNcrkwyAfFUrlU9Ep+Phf6fYVSts/a6m/cVs7a8gbk2ug1WT0TprrEO2Wj3P01uGdqM8r7UhMYxpN1OtZM7b8U7KSDgu3V0nDQ1B/hZmp/0MiOcNLtHrDtrtd3plucXUl/vxLUMDo4w+4mM70r3hwYFP9dlWrgqlzxhmw97ARxAmJHJgaQUhSs0avbkCDXsKDYpB0wWwNXpQOO2HrUCeI6IHZkYgBzuQOOCHKNKjlSusMNGdkroBbniBynP53bVa+x4ieM7NXRlTFN4LHIF0k5cDZFTxod0cc1gccVRI+YrLqHlLAt1f6U0RmFpNss+GueGIUY2iz4Y/Lnmdm52niNFX8+CecCEs5mEs4WEs5WEs42Es6FJJztJJyLSDgXk3AuIeFcSsK5jIRzOQlnmoSzg4RzBQnnShLOVSScq0k415BwriXhXEfCuZ6EcwMJ50YSzgwJ5yajM3cqzbmZRM8tJJxbBfwe9k0WTc5tJHpuJ+HcIef3UJNzJ4meu0g4d8v5vVeTcw+JnntJOPfJ+f2ZJud+Ej0PkHB6cn4va3L6JHpmSThzcn7v0eTMk+hZIOHslPN7SZOzSKJnQMJZkvN7oMl5kETPQyScXXJ+L2pyHibR8wgJ51E5v3dqcnaT6HmMhPO4nN8LmpwnSPQ8ScJ5Ss7veU3O0yR6niHhPCvn95wm5zkSPc+TcF6Q83tWk/MiiZ6XSDgvy/nd1+S8QqLnVRLOa3J+V+W8TqLnDRLOm2J+D1Xj77dI9LxNwnlHzu+q8fe7JHreI+G8L+d31fj7AxI9H5JwPpLzu2r8/TGJnk9IOJ/K+V01/t5DomeZhPOZnN97NDl7SfQMSTj7xPzeqxp/f06i5wthzlSMNRn52z1A4Ry8YwLvXMD7DPCuAOThI8cd+ePIzUbeM3KKka+LXNgllQ05nMiPRO4h8vqQM4d8NOR6IY8KOUrI/0FuDfJWkBOCfAvkMmTM5DvbNlc2rB3HumysecZ6YqzVxTpYrDHF+k2sjcS6Q6zpw3o5rEVD4zDhg8k+TPRikh8BHgT3ENhFUB8dCvF3xLYRN0ZMFvFOF0s8VtkQX0LsBnERxBwwn4+5csxDY44X86eYm8S8H+bUMF+FuSDMs2AOA/MDePbGcy2eGfE8hmcdPEfgHh33v7i3xH0b7olwv4Fr+dPKhoEO4zvGToxLofUJ+uoL8/99dsZqjvLu9+7Rz19+3I0cmvBFvWPLbP3x+y/vz+sP76PH0rb+9qn5a1dX+1u33/WRZlu32LrV1uhHgu9hyTr7bTr2vQWmurRGPrfFjrn2N9X4v0Sdv5Oxeqpzp3qxUXuNY87mcltHeV07WmJ1R8SuoJa+s5/WsV/TVx2Rz+lYO6N6dwsxOHtu7JxnqksydsydG//NJOT5/DhLqsZ3ueL6TDqyz+n5F9wtimw2WgAA","debug_symbols":"ndTBCoQgEAbgd5lzBzUr61WWJawsBLGwWliid1+LgqggZm/ODN9cfsYJKlWMTa5t3faQvSYwbSkH3VpfTUDWVt9Ju1T9IN0AWcpEAMpW/sX5HECtjYIsZvM7AIoFDAtCLOBYEGFBjAUJFggsSJ+AOAdH0IKixX3YEd2FYGcRogVHi6e8ryJGi9vEKYmijVCSXE5J/GFuc6eU8d1QTs4XSLDGF4XTxugmP/4Wvv2RTsvCqK2sR1sepsO32ye771xbqmp0atm0zvz6Hw==","file_map":{"62":{"source":"use std::hash::poseidon2::Poseidon2::hash as poseidon2;\n\nuse crate::common::{AdjacencyMap, GameState, MPCState, PlayerState, Territory};\nuse crate::common::constants::{\n    INITIAL_TROOPS_PER_PLAYER, MAX_PLAYERS, MAX_TERRITORIES, MIN_REINFORCEMENTS,\n};\n\n#[export]\npub fn initialize_game_state(num_players: u32) -> GameState {\n    assert(num_players >= 2 & num_players <= MAX_PLAYERS, \"Invalid number of players\");\n\n    let mut game_state = GameState::default();\n\n    for i in 0..MAX_TERRITORIES {\n        let mut territory = Territory::default();\n        territory.id = i as Field;\n        game_state.territories[i] = territory;\n    }\n\n    game_state.game_ended = false;\n    game_state.turn_count = 0;\n    game_state.current_player = 1;\n    game_state.winner = 0;\n\n    game_state\n}\n\n#[export]\npub fn initialize_player_state(\n    player_id: Field,\n    encrypt_secret: Field,\n    mask_secret: Field,\n) -> PlayerState {\n    assert(player_id as u32 > 0 & player_id as u32 <= MAX_PLAYERS, \"Invalid player ID\");\n\n    // Validate secrets are non-zero\n    assert(encrypt_secret != 0, \"Encryption secret cannot be zero\");\n    assert(mask_secret != 0, \"Mask secret cannot be zero\");\n\n    let mut player_state = PlayerState::default();\n    player_state.player_id = player_id;\n    player_state.encrypt_secret = encrypt_secret;\n    player_state.mask_secret = mask_secret;\n    player_state.unallocated_troops = INITIAL_TROOPS_PER_PLAYER;\n    player_state.reinforcements = 0;\n    player_state.has_conquered_territory = false;\n\n    // Initialize territory visibility to false\n    for i in 0..MAX_TERRITORIES {\n        player_state.visible_territories[i] = false;\n    }\n\n    // Initialize territory view\n    for i in 0..MAX_TERRITORIES {\n        let mut territory = Territory::default();\n        territory.id = i as Field;\n        player_state.territories_view[i] = territory;\n    }\n\n    player_state\n}\n\n#[export]\npub fn create_risk_adjacency_map() -> AdjacencyMap {\n    let mut map = AdjacencyMap::default();\n\n    // Simple version of risk map with just 24 territories due to Noir bitshift constraint\n    // North America (9 territories)\n    map = map.add_adjacency(0, 1); // Alaska - Northwest Territory\n    map = map.add_adjacency(0, 3); // Alaska - Kamchatka (across the Bering Strait)\n    map = map.add_adjacency(1, 2); // Northwest Territory - Greenland\n    map = map.add_adjacency(1, 4); // Northwest Territory - Alberta\n    map = map.add_adjacency(2, 6); // Greenland - Quebec\n    map = map.add_adjacency(2, 14); // Greenland - Iceland\n    map = map.add_adjacency(3, 4); // Alberta - Ontario\n    map = map.add_adjacency(4, 5); // Ontario - Quebec\n    map = map.add_adjacency(4, 7); // Ontario - Eastern United States\n    map = map.add_adjacency(5, 7); // Quebec - Eastern United States\n    map = map.add_adjacency(6, 7); // Western United States - Eastern United States\n    map = map.add_adjacency(6, 8); // Western United States - Central America\n    map = map.add_adjacency(8, 9); // Central America - Venezuela\n\n    // South America (4 territories)\n    map = map.add_adjacency(9, 10); // Venezuela - Peru\n    map = map.add_adjacency(9, 11); // Venezuela - Brazil\n    map = map.add_adjacency(10, 11); // Peru - Brazil\n    map = map.add_adjacency(10, 12); // Peru - Argentina\n    map = map.add_adjacency(11, 12); // Brazil - Argentina\n    map = map.add_adjacency(11, 15); // Brazil - North Africa\n\n    // // Europe (7 territories)\n    map = map.add_adjacency(13, 14); // Great Britain - Iceland\n    map = map.add_adjacency(13, 15); // Great Britain - Western Europe\n    map = map.add_adjacency(13, 16); // Great Britain - Northern Europe\n    map = map.add_adjacency(13, 17); // Great Britain - Scandinavia\n    map = map.add_adjacency(14, 17); // Iceland - Scandinavia\n    map = map.add_adjacency(15, 16); // Western Europe - Northern Europe\n    map = map.add_adjacency(15, 18); // Western Europe - Southern Europe\n    map = map.add_adjacency(15, 21); // Western Europe - North Africa\n    map = map.add_adjacency(16, 17); // Northern Europe - Scandinavia\n    map = map.add_adjacency(16, 18); // Northern Europe - Southern Europe\n    map = map.add_adjacency(16, 19); // Northern Europe - Ukraine\n    map = map.add_adjacency(17, 19); // Scandinavia - Ukraine\n    map = map.add_adjacency(18, 19); // Southern Europe - Ukraine\n    map = map.add_adjacency(18, 21); // Southern Europe - North Africa\n    map = map.add_adjacency(18, 22); // Southern Europe - Egypt\n    // map = map.add_adjacency(18, 24); // Southern Europe - Middle East\n\n    // // Africa (6 territories)\n    map = map.add_adjacency(20, 21); // Congo - North Africa\n    map = map.add_adjacency(20, 22); // Congo - Egypt\n    map = map.add_adjacency(20, 23); // Congo - East Africa\n\n    map\n}\n\n#[export]\npub fn assign_initial_territories(\n    game_state: GameState,\n    num_players: u32,\n    random_seed: Field,\n) -> GameState {\n    assert(num_players >= 2 & num_players <= MAX_PLAYERS, \"Invalid number of players\");\n\n    let mut updated_state = game_state;\n\n    // Create deterministic \"random\" assignments based on the seed\n    for i in 0..MAX_TERRITORIES {\n        // Use poseidon hash to create pseudorandom values based on seed and territory ID\n        let hash_input = [random_seed, i as Field];\n        let rand_value = poseidon2(hash_input, 2);\n\n        // Assign to player 1 through num_players\n        let player = (rand_value as u32 % num_players) + 1;\n\n        // Update the game state\n        updated_state.territories[i].owner_id = player as Field;\n        updated_state.territories[i].troop_count = 1; // Start with 1 troop per territory\n    }\n\n    updated_state\n}\n\n#[export]\npub fn commit_to_user_secrets(\n    game_state: GameState,\n    encrypt_secret: Field,\n    mask_secret: Field,\n    player_id: Field,\n) -> GameState {\n    assert(player_id as u32 > 0 & player_id as u32 <= MAX_PLAYERS, \"Invalid player ID\");\n    assert(encrypt_secret != 0, \"Encryption secret cannot be zero\");\n    assert(mask_secret != 0, \"Mask secret cannot be zero\");\n\n    let mut updated = game_state;\n\n    // Hash the secrets to create commitments\n    let encrypt_hash = poseidon2([encrypt_secret, player_id], 2);\n    let mask_hash = poseidon2([mask_secret, player_id], 2);\n\n    // Store the commitments\n    let idx = (player_id - 1) as u32;\n    updated.mpc_state.user_encrypt_secret_hashes[idx] = encrypt_hash;\n    updated.mpc_state.user_mask_secret_hashes[idx] = mask_hash;\n\n    updated\n}\n\n#[export]\npub fn register_all_players(\n    game_state: GameState,\n    player_secrets: [(Field, Field); MAX_PLAYERS],\n) -> GameState {\n    let mut updated = game_state;\n\n    for i in 0..MAX_PLAYERS {\n        let player_id = (i + 1) as Field;\n        let (encrypt_secret, mask_secret) = player_secrets[i];\n\n        // Only process valid players with non-zero secrets\n        if (encrypt_secret as u32 != 0) & (mask_secret as u32 != 0) {\n            updated = commit_to_user_secrets(updated, encrypt_secret, mask_secret, player_id);\n        }\n    }\n\n    updated\n}\n\n#[export]\npub fn count_player_territories(game_state: GameState) -> [Field; MAX_PLAYERS + 1] {\n    let mut counts = [0; MAX_PLAYERS + 1];\n\n    for i in 0..MAX_TERRITORIES {\n        let owner = game_state.territories[i].owner_id;\n        if owner as u32 > 0 & owner as u32 <= MAX_PLAYERS {\n            let owner_idx = owner as u32;\n            counts[owner_idx] += 1;\n        }\n    }\n\n    counts\n}\n\npub fn calculate_reinforcements(game_state: GameState, player_id: Field) -> Field {\n    let territory_counts = count_player_territories(game_state);\n    let player_idx = player_id as u32;\n    let player_territory_count = territory_counts[player_idx];\n\n    // Basic rule: Number of territories divided by 3, with a minimum of 3\n    let reinforcements = player_territory_count / 3;\n\n    if reinforcements as u32 < MIN_REINFORCEMENTS {\n        MIN_REINFORCEMENTS as Field\n    } else {\n        reinforcements\n    }\n}\n\npub fn get_turn_reinforcements(game_state: GameState, player_state: PlayerState) -> PlayerState {\n    assert(game_state.current_player == player_state.player_id, \"Not this player's turn\");\n\n    let reinforcements = calculate_reinforcements(game_state, player_state.player_id);\n\n    // Update player state with new reinforcements\n    let mut updated_player = player_state;\n    updated_player.reinforcements = reinforcements as u32;\n    updated_player.unallocated_troops += reinforcements as u32;\n\n    updated_player\n}\n","path":"/Users/satyam/web3/noir/Risk/game_circuit/src/game_initialization.nr"}},"names":["initialize_player_state"],"brillig_names":["directive_integer_quotient","directive_invert"]}