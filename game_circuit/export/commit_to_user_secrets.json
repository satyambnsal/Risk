{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":10924308969194152343,"abi":{"parameters":[{"name":"game_state","type":{"kind":"struct","path":"common::GameState","fields":[{"name":"game_ended","type":{"kind":"boolean"}},{"name":"turn_count","type":{"kind":"field"}},{"name":"current_player","type":{"kind":"field"}},{"name":"territories","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"mpc_state","type":{"kind":"struct","path":"common::MPCState","fields":[{"name":"user_encrypt_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"user_mask_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"round_id","type":{"kind":"field"}}]}},{"name":"winner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"encrypt_secret","type":{"kind":"field"},"visibility":"private"},{"name":"mask_secret","type":{"kind":"field"},"visibility":"private"},{"name":"player_id","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"common::GameState","fields":[{"name":"game_ended","type":{"kind":"boolean"}},{"name":"turn_count","type":{"kind":"field"}},{"name":"current_player","type":{"kind":"field"}},{"name":"territories","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"mpc_state","type":{"kind":"struct","path":"common::MPCState","fields":[{"name":"user_encrypt_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"user_mask_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"round_id","type":{"kind":"field"}}]}},{"name":"winner","type":{"kind":"field"}}]},"visibility":"private"},"error_types":{"6400654836729835912":{"error_kind":"string","string":"Invalid player ID"},"9731500601468557507":{"error_kind":"string","string":"Mask secret cannot be zero"},"9983489688954325393":{"error_kind":"string","string":"Encryption secret cannot be zero"}}},"bytecode":"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","debug_symbols":"5dbBioMwEAbgd8nZQ2biZJK+ylKKbW0RRIu1C0vpu68W47oaVjrH7c2Y+QZHfiV3dcz3t/OuqE71VW0+7qqsD1lb1FW3uivk573rJav65bXNmlZtiL1PVF4du0sH9EjUqShztbH42CYKncD4143RAgMCgwJjBCYVGBIYu2783LDAOIGJ58AhjobMzKRaYEBg1nOwNEZg4jlwzgXjNc8NCUw8B554NLx4NhaYaA4sAAzGAuHUJItiQ3aoTVGPpUiRUmQI7xbZmL+LgTk0Bva0UqzHzqCtmxb3U/p3mJL0W0wJ8Sk5DVMi/IMpo/8zi+TGKZ2efctkBCYVGBIYKzAsME5g/OvGaoGJJxddCI01Zn4esPEc/CTYpvpX2rfdYt8UZVmcd9PTYnf7M2uKbF/mw/J0qw6T3fbrEnaCvzT1IT/emrzv9Nzr2n8D","file_map":{"25":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"62":{"source":"use std::hash::poseidon2::Poseidon2::hash as poseidon2;\n\nuse crate::common::{AdjacencyMap, GameState, MPCState, PlayerState, Territory};\nuse crate::common::constants::{\n    INITIAL_TROOPS_PER_PLAYER, MAX_PLAYERS, MAX_TERRITORIES, MIN_REINFORCEMENTS,\n};\n\n#[export]\npub fn initialize_game_state(num_players: u32) -> GameState {\n    assert(num_players >= 2 & num_players <= MAX_PLAYERS, \"Invalid number of players\");\n\n    let mut game_state = GameState::default();\n\n    for i in 0..MAX_TERRITORIES {\n        let mut territory = Territory::default();\n        territory.id = i as Field;\n        game_state.territories[i] = territory;\n    }\n\n    game_state.game_ended = false;\n    game_state.turn_count = 0;\n    game_state.current_player = 1;\n    game_state.winner = 0;\n\n    game_state\n}\n\n#[export]\npub fn initialize_player_state(\n    player_id: Field,\n    encrypt_secret: Field,\n    mask_secret: Field,\n) -> PlayerState {\n    assert(player_id as u32 > 0 & player_id as u32 <= MAX_PLAYERS, \"Invalid player ID\");\n\n    // Validate secrets are non-zero\n    assert(encrypt_secret != 0, \"Encryption secret cannot be zero\");\n    assert(mask_secret != 0, \"Mask secret cannot be zero\");\n\n    let mut player_state = PlayerState::default();\n    player_state.player_id = player_id;\n    player_state.encrypt_secret = encrypt_secret;\n    player_state.mask_secret = mask_secret;\n    player_state.unallocated_troops = INITIAL_TROOPS_PER_PLAYER;\n    player_state.reinforcements = 0;\n    player_state.has_conquered_territory = false;\n\n    // Initialize territory visibility to false\n    for i in 0..MAX_TERRITORIES {\n        player_state.visible_territories[i] = false;\n    }\n\n    // Initialize territory view\n    for i in 0..MAX_TERRITORIES {\n        let mut territory = Territory::default();\n        territory.id = i as Field;\n        player_state.territories_view[i] = territory;\n    }\n\n    player_state\n}\n\n#[export]\npub fn create_risk_adjacency_map() -> AdjacencyMap {\n    let mut map = AdjacencyMap::default();\n\n    // Simple version of risk map with just 24 territories due to Noir bitshift constraint\n    // North America (9 territories)\n    map = map.add_adjacency(0, 1); // Alaska - Northwest Territory\n    map = map.add_adjacency(0, 3); // Alaska - Kamchatka (across the Bering Strait)\n    map = map.add_adjacency(1, 2); // Northwest Territory - Greenland\n    map = map.add_adjacency(1, 4); // Northwest Territory - Alberta\n    map = map.add_adjacency(2, 6); // Greenland - Quebec\n    map = map.add_adjacency(2, 14); // Greenland - Iceland\n    map = map.add_adjacency(3, 4); // Alberta - Ontario\n    map = map.add_adjacency(4, 5); // Ontario - Quebec\n    map = map.add_adjacency(4, 7); // Ontario - Eastern United States\n    map = map.add_adjacency(5, 7); // Quebec - Eastern United States\n    map = map.add_adjacency(6, 7); // Western United States - Eastern United States\n    map = map.add_adjacency(6, 8); // Western United States - Central America\n    map = map.add_adjacency(8, 9); // Central America - Venezuela\n\n    // South America (4 territories)\n    map = map.add_adjacency(9, 10); // Venezuela - Peru\n    map = map.add_adjacency(9, 11); // Venezuela - Brazil\n    map = map.add_adjacency(10, 11); // Peru - Brazil\n    map = map.add_adjacency(10, 12); // Peru - Argentina\n    map = map.add_adjacency(11, 12); // Brazil - Argentina\n    map = map.add_adjacency(11, 15); // Brazil - North Africa\n\n    // // Europe (7 territories)\n    map = map.add_adjacency(13, 14); // Great Britain - Iceland\n    map = map.add_adjacency(13, 15); // Great Britain - Western Europe\n    map = map.add_adjacency(13, 16); // Great Britain - Northern Europe\n    map = map.add_adjacency(13, 17); // Great Britain - Scandinavia\n    map = map.add_adjacency(14, 17); // Iceland - Scandinavia\n    map = map.add_adjacency(15, 16); // Western Europe - Northern Europe\n    map = map.add_adjacency(15, 18); // Western Europe - Southern Europe\n    map = map.add_adjacency(15, 21); // Western Europe - North Africa\n    map = map.add_adjacency(16, 17); // Northern Europe - Scandinavia\n    map = map.add_adjacency(16, 18); // Northern Europe - Southern Europe\n    map = map.add_adjacency(16, 19); // Northern Europe - Ukraine\n    map = map.add_adjacency(17, 19); // Scandinavia - Ukraine\n    map = map.add_adjacency(18, 19); // Southern Europe - Ukraine\n    map = map.add_adjacency(18, 21); // Southern Europe - North Africa\n    map = map.add_adjacency(18, 22); // Southern Europe - Egypt\n    // map = map.add_adjacency(18, 24); // Southern Europe - Middle East\n\n    // // Africa (6 territories)\n    map = map.add_adjacency(20, 21); // Congo - North Africa\n    map = map.add_adjacency(20, 22); // Congo - Egypt\n    map = map.add_adjacency(20, 23); // Congo - East Africa\n\n    map\n}\n\n#[export]\npub fn assign_initial_territories(\n    game_state: GameState,\n    num_players: u32,\n    random_seed: Field,\n) -> GameState {\n    assert(num_players >= 2 & num_players <= MAX_PLAYERS, \"Invalid number of players\");\n\n    let mut updated_state = game_state;\n\n    // Create deterministic \"random\" assignments based on the seed\n    for i in 0..MAX_TERRITORIES {\n        // Use poseidon hash to create pseudorandom values based on seed and territory ID\n        let hash_input = [random_seed, i as Field];\n        let rand_value = poseidon2(hash_input, 2);\n\n        // Assign to player 1 through num_players\n        let player = (rand_value as u32 % num_players) + 1;\n\n        // Update the game state\n        updated_state.territories[i].owner_id = player as Field;\n        updated_state.territories[i].troop_count = 1; // Start with 1 troop per territory\n    }\n\n    updated_state\n}\n\n#[export]\npub fn commit_to_user_secrets(\n    game_state: GameState,\n    encrypt_secret: Field,\n    mask_secret: Field,\n    player_id: Field,\n) -> GameState {\n    assert(player_id as u32 > 0 & player_id as u32 <= MAX_PLAYERS, \"Invalid player ID\");\n    assert(encrypt_secret != 0, \"Encryption secret cannot be zero\");\n    assert(mask_secret != 0, \"Mask secret cannot be zero\");\n\n    let mut updated = game_state;\n\n    // Hash the secrets to create commitments\n    let encrypt_hash = poseidon2([encrypt_secret, player_id], 2);\n    let mask_hash = poseidon2([mask_secret, player_id], 2);\n\n    // Store the commitments\n    let idx = (player_id - 1) as u32;\n    updated.mpc_state.user_encrypt_secret_hashes[idx] = encrypt_hash;\n    updated.mpc_state.user_mask_secret_hashes[idx] = mask_hash;\n\n    updated\n}\n\n#[export]\npub fn register_all_players(\n    game_state: GameState,\n    player_secrets: [(Field, Field); MAX_PLAYERS],\n) -> GameState {\n    let mut updated = game_state;\n\n    for i in 0..MAX_PLAYERS {\n        let player_id = (i + 1) as Field;\n        let (encrypt_secret, mask_secret) = player_secrets[i];\n\n        // Only process valid players with non-zero secrets\n        if (encrypt_secret as u32 != 0) & (mask_secret as u32 != 0) {\n            updated = commit_to_user_secrets(updated, encrypt_secret, mask_secret, player_id);\n        }\n    }\n\n    updated\n}\n\n#[export]\npub fn count_player_territories(game_state: GameState) -> [Field; MAX_PLAYERS + 1] {\n    let mut counts = [0; MAX_PLAYERS + 1];\n\n    for i in 0..MAX_TERRITORIES {\n        let owner = game_state.territories[i].owner_id;\n        if owner as u32 > 0 & owner as u32 <= MAX_PLAYERS {\n            let owner_idx = owner as u32;\n            counts[owner_idx] += 1;\n        }\n    }\n\n    counts\n}\n\npub fn calculate_reinforcements(game_state: GameState, player_id: Field) -> Field {\n    let territory_counts = count_player_territories(game_state);\n    let player_idx = player_id as u32;\n    let player_territory_count = territory_counts[player_idx];\n\n    // Basic rule: Number of territories divided by 3, with a minimum of 3\n    let reinforcements = player_territory_count / 3;\n\n    if reinforcements as u32 < MIN_REINFORCEMENTS {\n        MIN_REINFORCEMENTS as Field\n    } else {\n        reinforcements\n    }\n}\n\npub fn get_turn_reinforcements(game_state: GameState, player_state: PlayerState) -> PlayerState {\n    assert(game_state.current_player == player_state.player_id, \"Not this player's turn\");\n\n    let reinforcements = calculate_reinforcements(game_state, player_state.player_id);\n\n    // Update player state with new reinforcements\n    let mut updated_player = player_state;\n    updated_player.reinforcements = reinforcements as u32;\n    updated_player.unallocated_troops += reinforcements as u32;\n\n    updated_player\n}\n","path":"/Users/satyam/web3/noir/Risk/game_circuit/src/game_initialization.nr"}},"names":["commit_to_user_secrets"],"brillig_names":["directive_integer_quotient","directive_invert"]}