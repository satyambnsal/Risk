{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":7617286772610931090,"abi":{"parameters":[{"name":"game_state","type":{"kind":"struct","path":"common::GameState","fields":[{"name":"game_ended","type":{"kind":"boolean"}},{"name":"turn_count","type":{"kind":"field"}},{"name":"current_player","type":{"kind":"field"}},{"name":"territories","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"mpc_state","type":{"kind":"struct","path":"common::MPCState","fields":[{"name":"user_encrypt_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"user_mask_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"round_id","type":{"kind":"field"}}]}},{"name":"winner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"player_state","type":{"kind":"struct","path":"common::PlayerState","fields":[{"name":"player_id","type":{"kind":"field"}},{"name":"encrypt_secret","type":{"kind":"field"}},{"name":"mask_secret","type":{"kind":"field"}},{"name":"visible_territories","type":{"kind":"array","length":24,"type":{"kind":"boolean"}}},{"name":"territories_view","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"unallocated_troops","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"reinforcements","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"has_conquered_territory","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"adjacency_map","type":{"kind":"struct","path":"common::AdjacencyMap","fields":[{"name":"adjacency","type":{"kind":"array","length":24,"type":{"kind":"integer","sign":"unsigned","width":32}}}]},"visibility":"private"},{"name":"move_data","type":{"kind":"struct","path":"common::FortifyMove","fields":[{"name":"from_territory_id","type":{"kind":"field"}},{"name":"to_territory_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"struct","path":"common::GameState","fields":[{"name":"game_ended","type":{"kind":"boolean"}},{"name":"turn_count","type":{"kind":"field"}},{"name":"current_player","type":{"kind":"field"}},{"name":"territories","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"mpc_state","type":{"kind":"struct","path":"common::MPCState","fields":[{"name":"user_encrypt_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"user_mask_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"round_id","type":{"kind":"field"}}]}},{"name":"winner","type":{"kind":"field"}}]},{"kind":"struct","path":"common::PlayerState","fields":[{"name":"player_id","type":{"kind":"field"}},{"name":"encrypt_secret","type":{"kind":"field"}},{"name":"mask_secret","type":{"kind":"field"}},{"name":"visible_territories","type":{"kind":"array","length":24,"type":{"kind":"boolean"}}},{"name":"territories_view","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"unallocated_troops","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"reinforcements","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"has_conquered_territory","type":{"kind":"boolean"}}]},{"kind":"boolean"}]},"visibility":"private"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"}}},"bytecode":"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","debug_symbols":"tZzdSitJFIXfJddedNXatau2rzIMB3/iISAq/gwMMu8+rUyrnE6mOR/uu3SSLyvKtxBWF77urveXLz9/HO5u7p9253+87m7vry6eD/d389Xrrkx6f/Lp4eLu7frp+eLxeXfea42z3f7u+u2h65+z3c3hdr87nx/+eTZDRqBGICdQJ9AgUACoTAQqBKrHoSgLpLqGRCAjUCOQE6gTaBAoAFQnAh03wspYIPNYQZVAIpAR6LgR9vmLaKoryAnUCTQIFJuQ918hTQQqBKoEOm5EG32BvPoKMgK1TcjLCnICdQINAh03ok91gXodX6Gz1Zvnb7u8ef646fPN5T3BpvSEkp5Q0xOUnmDpCS09wdMTenrC+IYE98+EskqI7IQ2pSeU9ISanqD0BEtPaOkJnp7Q0xPSO93SO+3pnfb0Tnt6pz29057eaU/vtKd32tM77emd9vRO9/RO9/RO9/RO9/RO9/RO9/RO9/RO9/RO9/RO9/ROj/ROj/ROj/ROj/ROj/ROj/ROj/ROj/ROj/ROj/ROR3qnI73Tkd7pSO90pHc60jsd6Z2O9E5Heqcju9N1mtITvqHTNmlJsNpXCfV7E+SrBH1HwsfealZXCZae0NITjnd6jI877jHZ14R3qBNoECgAdOLoQUwft6tidQOznjh6sAFVAolAx10LX6AxTdMKapvQ6o57PXH0YAPqm5CtoUGgo0aM+cbBAs1/zX+Fjh892IIKgSqBtAXNP8EKMgI18vWcQJ1Ag0DECBEjRIwQMUIikBGIGCFihIgRIkaIGGHECCNGGDHCiBFGjDBihBEjjBhhxAgjRjRiRCNGNGJEI0Y0YkQjRjRiRCNGNGJEI0Y4McKJEU6McGKEEyOcGOHECCdGODHCiRGdGNGJEZ0Y0YkRnRjRiRGdGNGJEZ0Y0YkRgxgxiBGDGDGIEYMYMYgRgxgxiBGDGDGIEUGMCGJEECOCGBHEiCBGBDEiiBFBjAhghKaJQIVAlUAikBGoEcgJ1Ak0CESMKMSIQowoxIhCjCjEiEKMKMSIQowoxAiyWYpsliKbpchmqUqMqMQIslmKbJYim6XIZimyWYpsliKbpchmKbJZimyWIpulyGYpslmKbJYim6XIZimyWYpsliKbpchmKbJZimyWIpulyGYpslmKbJYim6XIZimyWYpsliKbpchmKbJZimyWIpulyGYpslmKbJYim6XIZimyWYpsliKbpchmKbJZimyWIpulyGYpslnqxGY53+ddoHl1XUGNQL4JxVhBnUCDfL0A0InNcgMqBDpxYub/znzoxJHrDcgI1AjkBOoEGgQKAJ04N7wBFQIRI4IYEcSIIEYEMSKIEUGMCGCETROBCoEqgUQgI1AjkBOoE2gQiBhRiBGFGFGIEYUYUYgRhRhRiBHknKWRc5ZWiBGVGFGJEZUYUYkRlRhRiRGVGFGJEZUYUYkRIkaIGCFihIgRIkaIGCFihIgRIkaIGGHECCNGGDHCiBFGjDBihBEjjBhhxAgjRjRiRCNGNGJE+20j5ovLx8Pt7eHnj6//h3R++q+Lx8PF5e3+v8ubl7urL68+//2wvLLwD4/3V/vrl8f92ye9vzZ//L8=","file_map":{"61":{"source":"pub mod constants {\n    pub global MAX_PLAYERS: u32 = 2;\n    pub global MAX_TERRITORIES: u32 = 24;\n    pub global MAX_TROOPS_PER_TERRITORY: u32 = 100;\n    pub global INITIAL_TROOPS_PER_PLAYER: u32 = 40;\n    pub global MIN_REINFORCEMENTS: u32 = 3;\n}\n\npub struct Territory {\n    pub id: Field,\n    pub owner_id: Field,\n    pub troop_count: u32,\n}\n\nimpl Territory {\n    pub fn default() -> Self {\n        Territory { id: 0, owner_id: 0, troop_count: 0 }\n    }\n\n    pub fn encode(self) -> Field {\n        let id_part = self.id;\n        let owner_part = self.owner_id * 0x100;\n        let troops_part = (self.troop_count as Field) * 0x10000;\n\n        id_part + owner_part + troops_part\n    }\n\n    pub fn decode(encoded: Field) -> Self {\n        let id = encoded as u32 % 0x100;\n        let owner_id = (encoded as u32 / 0x100) % 0x100;\n        let troop_count = ((encoded as u32 / 0x10000) % 0x10000) as u32;\n\n        Territory { id: id as Field, owner_id: owner_id as Field, troop_count: troop_count }\n    }\n}\n\npub struct AdjacencyMap {\n    pub adjacency: [u32; constants::MAX_TERRITORIES],\n}\n\nimpl AdjacencyMap {\n    pub fn default() -> Self {\n        AdjacencyMap { adjacency: [0; constants::MAX_TERRITORIES] }\n    }\n\n    pub fn are_adjacent(self, from_territory: Field, to_territory: Field) -> bool {\n        let from_idx = from_territory as u32;\n        let to_bit = 1 << (to_territory as u8);\n\n        (self.adjacency[from_idx] & to_bit) != 0\n    }\n\n    // Add an adjacency between two territories (bidirectional)\n    pub fn add_adjacency(mut self, territory1: Field, territory2: Field) -> Self {\n        assert(\n            territory1 as u32 >= 0 & territory1 as u32 < constants::MAX_TERRITORIES,\n            \"Territory1 ID out of bounds\",\n        );\n        assert(\n            territory2 as u32 >= 0 & territory2 as u32 < constants::MAX_TERRITORIES,\n            \"Territory2 ID out of bounds\",\n        );\n\n        let t1_idx = territory1 as u32;\n        let t2_idx = territory2 as u32;\n\n        let t2_bit = 1 << t2_idx as u8;\n        let t1_bit = 1 << t1_idx as u8;\n\n        self.adjacency[t1_idx] |= t2_bit;\n        self.adjacency[t2_idx] |= t1_bit;\n\n        self\n    }\n}\n\npub struct MPCState {\n    pub user_encrypt_secret_hashes: [Field; constants::MAX_PLAYERS],\n    pub user_mask_secret_hashes: [Field; constants::MAX_PLAYERS],\n    pub round_id: Field,\n}\n\nimpl MPCState {\n    pub fn default() -> Self {\n        MPCState {\n            user_encrypt_secret_hashes: [0; constants::MAX_PLAYERS],\n            user_mask_secret_hashes: [0; constants::MAX_PLAYERS],\n            round_id: 0,\n        }\n    }\n}\n\npub struct GameState {\n    pub game_ended: bool,\n    pub turn_count: Field,\n    pub current_player: Field,\n    pub territories: [Territory; constants::MAX_TERRITORIES],\n    pub mpc_state: MPCState,\n    pub winner: Field, // 0 means no winner yet\n}\n\nimpl GameState {\n    pub fn default() -> Self {\n        GameState {\n            game_ended: false,\n            turn_count: 0,\n            current_player: 1,\n            territories: [Territory::default(); constants::MAX_TERRITORIES],\n            mpc_state: MPCState::default(),\n            winner: 0,\n        }\n    }\n}\n\npub struct PlayerState {\n    pub player_id: Field,\n    pub encrypt_secret: Field,\n    pub mask_secret: Field,\n    pub visible_territories: [bool; constants::MAX_TERRITORIES],\n    pub territories_view: [Territory; constants::MAX_TERRITORIES],\n    pub unallocated_troops: u32,\n    pub reinforcements: u32,\n    pub has_conquered_territory: bool,\n}\n\nimpl PlayerState {\n    pub fn default() -> Self {\n        PlayerState {\n            player_id: 0,\n            encrypt_secret: 0,\n            mask_secret: 0,\n            visible_territories: [false; constants::MAX_TERRITORIES],\n            territories_view: [Territory::default(); constants::MAX_TERRITORIES],\n            unallocated_troops: 0,\n            reinforcements: 0,\n            has_conquered_territory: false,\n        }\n    }\n}\n\npub struct TroopPlacementMove {\n    pub territory_id: Field,\n    pub troop_count: u32,\n}\n\npub struct AttackMove {\n    pub from_territory_id: Field,\n    pub to_territory_id: Field,\n    pub attack_troop_count: u32,\n    pub dice_roll_seed: Field,\n}\n\npub struct FortifyMove {\n    pub from_territory_id: Field,\n    pub to_territory_id: Field,\n    pub troop_count: u32,\n}\n\npub enum GameMove {\n    PlaceTroops(TroopPlacementMove),\n    Attack(AttackMove),\n    Fortify(FortifyMove),\n    EndTurn,\n}\n\npub struct AttackResult {\n    pub success: bool,\n    pub attacker_losses: u32,\n    pub defender_losses: u32,\n    pub territory_captured: bool,\n}\n\nimpl AttackResult {\n    pub fn default() -> Self {\n        AttackResult {\n            success: false,\n            attacker_losses: 0,\n            defender_losses: 0,\n            territory_captured: false,\n        }\n    }\n}\n","path":"/Users/satyam/web3/noir/Risk/game_circuit/src/common.nr"},"63":{"source":"// game_mechanics.nr\nuse dep::std;\nuse std::hash::poseidon2::Poseidon2::hash as poseidon2;\n\nuse crate::common::{\n    AdjacencyMap, AttackMove, AttackResult, FortifyMove, GameMove, GameState, PlayerState,\n    Territory, TroopPlacementMove,\n};\nuse crate::common::constants::{MAX_PLAYERS, MAX_TERRITORIES};\n\n// Place troops on a territory\n#[export]\npub fn place_troops(\n    game_state: GameState,\n    player_state: PlayerState,\n    move_data: TroopPlacementMove,\n) -> (GameState, PlayerState, bool) {\n    let territory_id = move_data.territory_id;\n    let troop_count = move_data.troop_count;\n\n    // Validation checks\n    let player_turn = game_state.current_player == player_state.player_id;\n    let owns_territory =\n        game_state.territories[territory_id as u32].owner_id == player_state.player_id;\n    let has_enough_troops = troop_count > 0 & troop_count <= player_state.unallocated_troops;\n\n    let valid_move = player_turn & owns_territory & has_enough_troops;\n\n    if valid_move {\n        // Update game and player state\n        let mut updated_game = game_state;\n        let mut updated_player = player_state;\n\n        updated_game.territories[territory_id as u32].troop_count += troop_count;\n        updated_player.unallocated_troops -= troop_count;\n\n        (updated_game, updated_player, true)\n    } else {\n        (game_state, player_state, false)\n    }\n}\n\n// Generate a dice roll using player secrets for randomness\nfn roll_dice(\n    attacker_secret: Field,\n    defender_id: Field,\n    from_territory: Field,\n    to_territory: Field,\n    num_dice: u32,\n    nonce: Field,\n) -> [u32; 3] {\n    // Return up to 3 dice values\n    let mut dice_values = [0; 3];\n\n    for i in 0..3 {\n        if i < num_dice {\n            // Create a unique seed for each die\n            let hash_input =\n                [attacker_secret, defender_id, from_territory, to_territory, i as Field, nonce];\n\n            let seed = poseidon2(hash_input, 6);\n\n            // Convert to a number between 1-6\n            dice_values[i] = ((seed as u32 % 6) + 1) as u32;\n        }\n    }\n\n    dice_values\n}\n\n// Sort an array of dice values in descending order\nunconstrained fn sort_dice(dice: [u32; 3], count: u32) -> [u32; 3] {\n    let mut sorted = dice;\n\n    // Simple bubble sort\n    for i in 0..count {\n        for j in 0..(count - i - 1) {\n            if sorted[j] < sorted[j + 1] {\n                let temp = sorted[j];\n                sorted[j] = sorted[j + 1];\n                sorted[j + 1] = temp;\n            }\n        }\n    }\n\n    sorted\n}\n\n#[export]\npub fn execute_attack(\n    game_state: GameState,\n    player_state: PlayerState,\n    adjacency_map: AdjacencyMap,\n    move_data: AttackMove,\n) -> (GameState, PlayerState, AttackResult) {\n    let from_territory_id = move_data.from_territory_id as u32;\n    let to_territory_id = move_data.to_territory_id as u32;\n    let attack_troop_count = move_data.attack_troop_count;\n\n    // Default result\n    let mut result = AttackResult::default();\n\n    // Validation checks\n    let player_turn = game_state.current_player == player_state.player_id;\n    let owns_from = game_state.territories[from_territory_id].owner_id == player_state.player_id;\n    let doesnt_own_to = game_state.territories[to_territory_id].owner_id != player_state.player_id;\n    let territories_adjacent =\n        adjacency_map.are_adjacent(from_territory_id as Field, to_territory_id as Field);\n    let from_troops = game_state.territories[from_territory_id].troop_count;\n    let has_enough_troops = attack_troop_count > 0 & attack_troop_count < from_troops;\n\n    let valid_attack =\n        player_turn & owns_from & doesnt_own_to & territories_adjacent & has_enough_troops;\n\n    assert(valid_attack == true, \"attack should be valid\");\n\n    // The attack is valid, proceed with the battle\n    result.success = true;\n\n    // Determine number of dice\n    let attacker_dice = if attack_troop_count >= 3 {\n        3\n    } else {\n        attack_troop_count\n    };\n\n    let defender_troops = game_state.territories[to_territory_id].troop_count;\n    let defender_dice = if defender_troops >= 2 { 2 } else { 1 };\n\n    // Roll and sort dice\n    let defender_id = game_state.territories[to_territory_id].owner_id;\n    let nonce = move_data.dice_roll_seed;\n\n    let attacker_rolls = roll_dice(\n        player_state.encrypt_secret,\n        defender_id,\n        from_territory_id as Field,\n        to_territory_id as Field,\n        attacker_dice,\n        nonce,\n    );\n\n    // Simulate defender rolls (in real game, defender would use their own secret)\n    let defender_secret = poseidon2([player_state.encrypt_secret, defender_id], 2);\n\n    let defender_rolls = roll_dice(\n        defender_secret,\n        player_state.player_id,\n        to_territory_id as Field,\n        from_territory_id as Field,\n        defender_dice,\n        nonce,\n    );\n    println(f\"attacker roles: {attacker_rolls}\");\n    println(f\"defender roles: {defender_rolls}\");\n    let mut sorted_attacker = [0, 0, 0];\n    let mut sorted_defender = [0, 0, 0];\n\n    unsafe {\n        sorted_attacker = sort_dice(attacker_rolls, attacker_dice);\n        sorted_defender = sort_dice(defender_rolls, defender_dice);\n    }\n    // Sort dice in descending order\n\n    // Compare dice and compute casualties\n    let mut attacker_losses = 0;\n    let mut defender_losses = 0;\n    let compare_count = if defender_dice < attacker_dice {\n        defender_dice\n    } else {\n        attacker_dice\n    };\n\n    unsafe {\n        let result = calculate_losses(compare_count, sorted_attacker, sorted_defender);\n        attacker_losses = result.0;\n        defender_losses = result.1;\n    }\n    // Update result with battle outcome\n    result.attacker_losses = attacker_losses;\n    result.defender_losses = defender_losses;\n\n    // Update game state based on the outcome\n    let mut updated_game = game_state;\n    let mut updated_player = player_state;\n\n    // Check if the territory was conquered\n    let territory_conquered = defender_losses >= defender_troops;\n    result.territory_captured = territory_conquered;\n\n    if territory_conquered {\n        // Attacker conquers the territory\n        let remaining_attack_troops = attack_troop_count - attacker_losses;\n        updated_game.territories[to_territory_id].owner_id = player_state.player_id;\n        updated_game.territories[to_territory_id].troop_count = remaining_attack_troops;\n        updated_game.territories[from_territory_id].troop_count -=\n            (remaining_attack_troops + attacker_losses);\n\n        // Mark that player has conquered a territory this turn (for cards)\n        updated_player.has_conquered_territory = true;\n    } else {\n        // Defender keeps the territory with reduced troops\n        updated_game.territories[from_territory_id].troop_count -= attacker_losses;\n        updated_game.territories[to_territory_id].troop_count -= defender_losses;\n    }\n\n    // Check for win condition\n    updated_game = check_win_condition(updated_game);\n\n    (updated_game, updated_player, result)\n}\n\n#[export]\npub fn execute_fortify(\n    game_state: GameState,\n    player_state: PlayerState,\n    adjacency_map: AdjacencyMap,\n    move_data: FortifyMove,\n) -> (GameState, PlayerState, bool) {\n    let from_territory_id = move_data.from_territory_id as u32;\n    let to_territory_id = move_data.to_territory_id as u32;\n    let troop_count = move_data.troop_count;\n\n    // Validation checks\n    let player_turn = game_state.current_player == player_state.player_id;\n    let owns_from = game_state.territories[from_territory_id].owner_id == player_state.player_id;\n    let owns_to = game_state.territories[to_territory_id].owner_id == player_state.player_id;\n    let territories_adjacent =\n        adjacency_map.are_adjacent(from_territory_id as Field, to_territory_id as Field);\n    let from_troops = game_state.territories[from_territory_id].troop_count;\n    let has_enough_troops = troop_count > 0 & troop_count < from_troops;\n\n    let valid_fortify =\n        player_turn & owns_from & owns_to & territories_adjacent & has_enough_troops;\n\n    if valid_fortify {\n        // Update game state\n        let mut updated_game = game_state;\n\n        updated_game.territories[from_territory_id].troop_count -= troop_count;\n        updated_game.territories[to_territory_id].troop_count += troop_count;\n\n        (updated_game, player_state, true)\n    } else {\n        (game_state, player_state, false)\n    }\n}\n\n#[export]\npub fn check_win_condition(game_state: GameState) -> GameState {\n    let mut updated_game = game_state;\n    let territory_counts = count_player_territories(game_state);\n\n    // Check if any player owns all territories\n    for player_id in 1..=MAX_PLAYERS {\n        if territory_counts[player_id] as u32 == MAX_TERRITORIES {\n            updated_game.game_ended = true;\n            updated_game.winner = player_id as Field;\n        }\n    }\n\n    updated_game\n}\n\n// Count territories owned by each player\npub fn count_player_territories(game_state: GameState) -> [Field; MAX_PLAYERS + 1] {\n    let mut counts = [0; MAX_PLAYERS + 1];\n\n    for i in 0..MAX_TERRITORIES {\n        let owner = game_state.territories[i].owner_id;\n        if owner as u32 > 0 & owner as u32 <= MAX_PLAYERS {\n            let owner_idx = owner as u32;\n            counts[owner_idx] += 1;\n        }\n    }\n\n    counts\n}\n\n#[export]\npub fn end_turn(game_state: GameState) -> GameState {\n    // Ensure the game has not ended\n    assert(!game_state.game_ended, \"Game has already ended\");\n\n    let mut updated_game = game_state;\n\n    // Find the next active player\n    let current_player = game_state.current_player;\n    let mut next_player = current_player + 1;\n\n    // Wrap around to player 1 if we reach beyond max players\n    if next_player as u32 > MAX_PLAYERS {\n        next_player = 1;\n    }\n\n    // Update game state\n    updated_game.current_player = next_player;\n    updated_game.turn_count += 1;\n\n    updated_game\n}\n\npub fn execute_move(\n    game_state: GameState,\n    player_state: PlayerState,\n    adjacency_map: AdjacencyMap,\n    game_move: GameMove,\n) -> (GameState, PlayerState, bool) {\n    match game_move {\n        GameMove::PlaceTroops(move_data) => { place_troops(game_state, player_state, move_data) },\n        GameMove::Attack(move_data) => {\n            let (updated_game, updated_player, result) =\n                execute_attack(game_state, player_state, adjacency_map, move_data);\n            (updated_game, updated_player, result.success)\n        },\n        GameMove::Fortify(move_data) => {\n            execute_fortify(game_state, player_state, adjacency_map, move_data)\n        },\n        GameMove::EndTurn => {\n            if game_state.current_player == player_state.player_id {\n                let updated_game = end_turn(game_state);\n                (updated_game, player_state, true)\n            } else {\n                (game_state, player_state, false)\n            }\n        },\n        _ => (game_state, player_state, false),\n    }\n}\n\nunconstrained fn calculate_losses(\n    compare_count: u32,\n    sorted_attacker: [u32; 3],\n    sorted_defender: [u32; 3],\n) -> (u32, u32) {\n    let mut defender_losses = 0;\n    let mut attacker_losses = 0;\n    for i in 0..compare_count {\n        if sorted_attacker[i] > sorted_defender[i] {\n            defender_losses += 1;\n        } else {\n            attacker_losses += 1;\n        }\n    }\n    (attacker_losses, defender_losses)\n}\n","path":"/Users/satyam/web3/noir/Risk/game_circuit/src/game_mechanics.nr"}},"names":["execute_fortify"],"brillig_names":["directive_integer_quotient","directive_invert","directive_to_radix"]}