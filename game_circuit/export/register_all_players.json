{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":4786855546083027205,"abi":{"parameters":[{"name":"game_state","type":{"kind":"struct","path":"common::GameState","fields":[{"name":"game_ended","type":{"kind":"boolean"}},{"name":"turn_count","type":{"kind":"field"}},{"name":"current_player","type":{"kind":"field"}},{"name":"territories","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"mpc_state","type":{"kind":"struct","path":"common::MPCState","fields":[{"name":"user_encrypt_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"user_mask_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"round_id","type":{"kind":"field"}}]}},{"name":"winner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"player_secrets","type":{"kind":"array","length":2,"type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"}]}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"common::GameState","fields":[{"name":"game_ended","type":{"kind":"boolean"}},{"name":"turn_count","type":{"kind":"field"}},{"name":"current_player","type":{"kind":"field"}},{"name":"territories","type":{"kind":"array","length":24,"type":{"kind":"struct","path":"common::Territory","fields":[{"name":"id","type":{"kind":"field"}},{"name":"owner_id","type":{"kind":"field"}},{"name":"troop_count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"mpc_state","type":{"kind":"struct","path":"common::MPCState","fields":[{"name":"user_encrypt_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"user_mask_secret_hashes","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"round_id","type":{"kind":"field"}}]}},{"name":"winner","type":{"kind":"field"}}]},"visibility":"private"},"error_types":{"9731500601468557507":{"error_kind":"string","string":"Mask secret cannot be zero"},"9983489688954325393":{"error_kind":"string","string":"Encryption secret cannot be zero"}}},"bytecode":"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","debug_symbols":"7Zldb6pAEIb/C9de7Mx+zfavnJw0qNiQEDSoJzkx/e+FRqzFVsMrc2O8c2GefchkN7Cvh2xZzPdvr2W9Wm+zlz+HrFov8l25rtvRIeP4eW27yetuuN3lzS57CWLSLCvqZffTmvdZtiqroh3w+99ZxgIwaTxjDcAQwDDAWIBxAOMBJtxm/JCJACMA88s6cObEeBkwzgAMAQwDjAUYBzAeYALARICRm0ywQyaNZ7wBmF/WgZzWaArf9s/sotiLyLHYJxOHAtYWWG2B0xZ4bUG4X5B8PAnixSqK2gLRFiRlQTB3CwIR9cXk+Xqx9eFY6/hrXvY/lHKk/iE4Wnu9mGLsJ6aY/I1ic5qZTJDz4q4l9GzJsCX8bMmwJfbZkmFL3AQtia4vZnqAltz/Dg0s/dMEe/FhHoK2IGoLRFuQlAXRaAsmeCN9bZbgDA8FrC2w2gKnLfDagqAtGLuTO0YAJo1nxAAMAQwDjAUYBzBAZiQBYIDsUIDsUIDsMAHZYQKywwRkhwnIDpMbn7UlDzBAdpiAzCgJwADZIRmDQIRAjEAWgRwCeQS6HSFeRG5kIgIJAk2QalxNloiMuoHUDaxusOqG+z/LrudXRF7dENQNUd0wwSHrwdIKovTsybAnPEUc/FgRDjFwziAefdBoB/OmrKry7fX8r/728r+8KfN5VRyHq329OLu7+7/p7/T8plkviuW+KbqZPu+1038A","file_map":{"25":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"62":{"source":"use std::hash::poseidon2::Poseidon2::hash as poseidon2;\n\nuse crate::common::{AdjacencyMap, GameState, MPCState, PlayerState, Territory};\nuse crate::common::constants::{\n    INITIAL_TROOPS_PER_PLAYER, MAX_PLAYERS, MAX_TERRITORIES, MIN_REINFORCEMENTS,\n};\n\n#[export]\npub fn initialize_game_state(num_players: u32) -> GameState {\n    assert(num_players >= 2 & num_players <= MAX_PLAYERS, \"Invalid number of players\");\n\n    let mut game_state = GameState::default();\n\n    for i in 0..MAX_TERRITORIES {\n        let mut territory = Territory::default();\n        territory.id = i as Field;\n        game_state.territories[i] = territory;\n    }\n\n    game_state.game_ended = false;\n    game_state.turn_count = 0;\n    game_state.current_player = 1;\n    game_state.winner = 0;\n\n    game_state\n}\n\n#[export]\npub fn initialize_player_state(\n    player_id: Field,\n    encrypt_secret: Field,\n    mask_secret: Field,\n) -> PlayerState {\n    assert(player_id as u32 > 0 & player_id as u32 <= MAX_PLAYERS, \"Invalid player ID\");\n\n    // Validate secrets are non-zero\n    assert(encrypt_secret != 0, \"Encryption secret cannot be zero\");\n    assert(mask_secret != 0, \"Mask secret cannot be zero\");\n\n    let mut player_state = PlayerState::default();\n    player_state.player_id = player_id;\n    player_state.encrypt_secret = encrypt_secret;\n    player_state.mask_secret = mask_secret;\n    player_state.unallocated_troops = INITIAL_TROOPS_PER_PLAYER;\n    player_state.reinforcements = 0;\n    player_state.has_conquered_territory = false;\n\n    // Initialize territory visibility to false\n    for i in 0..MAX_TERRITORIES {\n        player_state.visible_territories[i] = false;\n    }\n\n    // Initialize territory view\n    for i in 0..MAX_TERRITORIES {\n        let mut territory = Territory::default();\n        territory.id = i as Field;\n        player_state.territories_view[i] = territory;\n    }\n\n    player_state\n}\n\n#[export]\npub fn create_risk_adjacency_map() -> AdjacencyMap {\n    let mut map = AdjacencyMap::default();\n\n    // Simple version of risk map with just 24 territories due to Noir bitshift constraint\n    // North America (9 territories)\n    map = map.add_adjacency(0, 1); // Alaska - Northwest Territory\n    map = map.add_adjacency(0, 3); // Alaska - Kamchatka (across the Bering Strait)\n    map = map.add_adjacency(1, 2); // Northwest Territory - Greenland\n    map = map.add_adjacency(1, 4); // Northwest Territory - Alberta\n    map = map.add_adjacency(2, 6); // Greenland - Quebec\n    map = map.add_adjacency(2, 14); // Greenland - Iceland\n    map = map.add_adjacency(3, 4); // Alberta - Ontario\n    map = map.add_adjacency(4, 5); // Ontario - Quebec\n    map = map.add_adjacency(4, 7); // Ontario - Eastern United States\n    map = map.add_adjacency(5, 7); // Quebec - Eastern United States\n    map = map.add_adjacency(6, 7); // Western United States - Eastern United States\n    map = map.add_adjacency(6, 8); // Western United States - Central America\n    map = map.add_adjacency(8, 9); // Central America - Venezuela\n\n    // South America (4 territories)\n    map = map.add_adjacency(9, 10); // Venezuela - Peru\n    map = map.add_adjacency(9, 11); // Venezuela - Brazil\n    map = map.add_adjacency(10, 11); // Peru - Brazil\n    map = map.add_adjacency(10, 12); // Peru - Argentina\n    map = map.add_adjacency(11, 12); // Brazil - Argentina\n    map = map.add_adjacency(11, 15); // Brazil - North Africa\n\n    // // Europe (7 territories)\n    map = map.add_adjacency(13, 14); // Great Britain - Iceland\n    map = map.add_adjacency(13, 15); // Great Britain - Western Europe\n    map = map.add_adjacency(13, 16); // Great Britain - Northern Europe\n    map = map.add_adjacency(13, 17); // Great Britain - Scandinavia\n    map = map.add_adjacency(14, 17); // Iceland - Scandinavia\n    map = map.add_adjacency(15, 16); // Western Europe - Northern Europe\n    map = map.add_adjacency(15, 18); // Western Europe - Southern Europe\n    map = map.add_adjacency(15, 21); // Western Europe - North Africa\n    map = map.add_adjacency(16, 17); // Northern Europe - Scandinavia\n    map = map.add_adjacency(16, 18); // Northern Europe - Southern Europe\n    map = map.add_adjacency(16, 19); // Northern Europe - Ukraine\n    map = map.add_adjacency(17, 19); // Scandinavia - Ukraine\n    map = map.add_adjacency(18, 19); // Southern Europe - Ukraine\n    map = map.add_adjacency(18, 21); // Southern Europe - North Africa\n    map = map.add_adjacency(18, 22); // Southern Europe - Egypt\n    // map = map.add_adjacency(18, 24); // Southern Europe - Middle East\n\n    // // Africa (6 territories)\n    map = map.add_adjacency(20, 21); // Congo - North Africa\n    map = map.add_adjacency(20, 22); // Congo - Egypt\n    map = map.add_adjacency(20, 23); // Congo - East Africa\n\n    map\n}\n\n#[export]\npub fn assign_initial_territories(\n    game_state: GameState,\n    num_players: u32,\n    random_seed: Field,\n) -> GameState {\n    assert(num_players >= 2 & num_players <= MAX_PLAYERS, \"Invalid number of players\");\n\n    let mut updated_state = game_state;\n\n    // Create deterministic \"random\" assignments based on the seed\n    for i in 0..MAX_TERRITORIES {\n        // Use poseidon hash to create pseudorandom values based on seed and territory ID\n        let hash_input = [random_seed, i as Field];\n        let rand_value = poseidon2(hash_input, 2);\n\n        // Assign to player 1 through num_players\n        let player = (rand_value as u32 % num_players) + 1;\n\n        // Update the game state\n        updated_state.territories[i].owner_id = player as Field;\n        updated_state.territories[i].troop_count = 1; // Start with 1 troop per territory\n    }\n\n    updated_state\n}\n\n#[export]\npub fn commit_to_user_secrets(\n    game_state: GameState,\n    encrypt_secret: Field,\n    mask_secret: Field,\n    player_id: Field,\n) -> GameState {\n    assert(player_id as u32 > 0 & player_id as u32 <= MAX_PLAYERS, \"Invalid player ID\");\n    assert(encrypt_secret != 0, \"Encryption secret cannot be zero\");\n    assert(mask_secret != 0, \"Mask secret cannot be zero\");\n\n    let mut updated = game_state;\n\n    // Hash the secrets to create commitments\n    let encrypt_hash = poseidon2([encrypt_secret, player_id], 2);\n    let mask_hash = poseidon2([mask_secret, player_id], 2);\n\n    // Store the commitments\n    let idx = (player_id - 1) as u32;\n    updated.mpc_state.user_encrypt_secret_hashes[idx] = encrypt_hash;\n    updated.mpc_state.user_mask_secret_hashes[idx] = mask_hash;\n\n    updated\n}\n\n#[export]\npub fn register_all_players(\n    game_state: GameState,\n    player_secrets: [(Field, Field); MAX_PLAYERS],\n) -> GameState {\n    let mut updated = game_state;\n\n    for i in 0..MAX_PLAYERS {\n        let player_id = (i + 1) as Field;\n        let (encrypt_secret, mask_secret) = player_secrets[i];\n\n        // Only process valid players with non-zero secrets\n        if (encrypt_secret as u32 != 0) & (mask_secret as u32 != 0) {\n            updated = commit_to_user_secrets(updated, encrypt_secret, mask_secret, player_id);\n        }\n    }\n\n    updated\n}\n\n#[export]\npub fn count_player_territories(game_state: GameState) -> [Field; MAX_PLAYERS + 1] {\n    let mut counts = [0; MAX_PLAYERS + 1];\n\n    for i in 0..MAX_TERRITORIES {\n        let owner = game_state.territories[i].owner_id;\n        if owner as u32 > 0 & owner as u32 <= MAX_PLAYERS {\n            let owner_idx = owner as u32;\n            counts[owner_idx] += 1;\n        }\n    }\n\n    counts\n}\n\npub fn calculate_reinforcements(game_state: GameState, player_id: Field) -> Field {\n    let territory_counts = count_player_territories(game_state);\n    let player_idx = player_id as u32;\n    let player_territory_count = territory_counts[player_idx];\n\n    // Basic rule: Number of territories divided by 3, with a minimum of 3\n    let reinforcements = player_territory_count / 3;\n\n    if reinforcements as u32 < MIN_REINFORCEMENTS {\n        MIN_REINFORCEMENTS as Field\n    } else {\n        reinforcements\n    }\n}\n\npub fn get_turn_reinforcements(game_state: GameState, player_state: PlayerState) -> PlayerState {\n    assert(game_state.current_player == player_state.player_id, \"Not this player's turn\");\n\n    let reinforcements = calculate_reinforcements(game_state, player_state.player_id);\n\n    // Update player state with new reinforcements\n    let mut updated_player = player_state;\n    updated_player.reinforcements = reinforcements as u32;\n    updated_player.unallocated_troops += reinforcements as u32;\n\n    updated_player\n}\n","path":"/Users/satyam/web3/noir/Risk/game_circuit/src/game_initialization.nr"}},"names":["register_all_players"],"brillig_names":["directive_integer_quotient","directive_invert"]}